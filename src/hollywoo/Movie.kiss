(defMacro makeCC [errorCC &body b]
    `->:Void [] (runWithErrorChecking ->:Void {,@b} ,errorCC))

(function dynamicArray [&rest :Array<Dynamic> elements]
    elements)

(function opposite [:StagePosition position]
    (new StagePosition -position.x -position.y -position.z))

(defMacro unlessCancel [keyName exp]
    `(lambda [,keyName]
        (if (= ,keyName CANCEL_COMMAND)
                (cc)
            ,exp)))

// This file is designed to be loaded again by subclasses, with macroVar "subclass" set
(#unless subclass

    // Settings
    (savedVar :Bool showCaptions false)
    (savedVar :PlayMode playMode NotSet)

    (var MAX_CAPTION_DURATION 3)
    (prop &mut :Int captionId 0)

    (prop :Array<HistoryElement<Actor>> dialogHistory [])
    (var MAX_DIALOG_HISTORY 50)

    (prop &mut :String currentSong "")
    (prop &mut :Float currentSongVolumeMod 0)
    (prop &mut :Bool currentSongLooping false)

    // Mostly immutable, reusable resources:
    (prop :FuzzyMap<Set> sets (new FuzzyMap<Set>))
    (prop :FuzzyMap<Actor> actors (new FuzzyMap<Actor>))
    (prop :FuzzyMap<Sound> sounds (new FuzzyMap<Sound>))
    (prop :FuzzyMap<String> soundDescriptions (new FuzzyMap<String>))
    (prop :FuzzyMap<Song> songs (new FuzzyMap<Song>))
    (prop :FuzzyMap<Prop> props (new FuzzyMap<Prop>))
    (prop :Map<String,VoiceTrack> voiceTracks (new Map))
    (prop :Map<String,CustomDialogTypeHandler<Actor>> _customDialogTypeHandlers (new Map))
    (prop :FuzzyMap<FuzzyMap<VoiceLine>> voiceLines (new FuzzyMap<FuzzyMap<VoiceLine>>))
    (prop :Map<String,Bool> dirtyActors (new Map))
    (prop :Map<String,Bool> dirtyProps (new Map))

    // Used to give unique, persistent IDs to voice tracks
    (prop :Map<String,Int> voiceTracksPerActor (new Map))

    (prop &mut :DelayHandling delayHandling AutoWithSkip)

    (prop &mut :String lastDelay "")
    (prop &mut :Float lastDelayLength 0)


    // Mutable representation of frames in time:
    (prop :FuzzyMap<Scene<Set,Actor,Prop,Camera>> scenes (new FuzzyMap<Scene<Set,Actor,Prop,Camera>>))

    (prop :Map<String,Bool> shownScenes (new Map))
    (prop :Map<String,Bool> shownProps (new Map))
    (prop :Map<String,Bool> shownCharacters (new Map))

    // This is set and unset by doPreload defined in HollywooDSL.kiss
    (prop &mut isLoading false)
    (prop &mut didLoading false)

    (prop &mut scavenged false)
    // Reuse as many loaded assets from the previously running Movie as safely possible
    (method scavengeObjects [:Movie<Set,Actor,Sound,Song,Prop,VoiceTrack,Camera,LightSource> movie]
        (set scavenged true)
        (let [&mut t 0
                &mut c 0]
            (doFor =>key actor movie.actors
                (+= t 1)
                (unless (movie.dirtyActors.exists key)
                    (+= c 1)
                    (dictSet actors key actor)
                    (movie.actors.remove key)))
            (doFor =>key prop movie.props
                (+= t 1)
                (unless (movie.dirtyProps.exists key)
                    (+= c 1)
                    (dictSet props key prop)
                    (movie.props.remove key)))
            (doFor =>key sound movie.sounds
                (+= t 1)
                (+= c 1)
                (dictSet soundDescriptions key (dictGet movie.soundDescriptions key))
                (dictSet sounds key sound)
                (movie.sounds.remove key))
            (doFor =>key song movie.songs
                (+= t 1)
                (+= c 1)
                (dictSet songs key song)
                (movie.songs.remove key))
            (doFor =>key voiceTrack movie.voiceTracks
                (+= t 1)
                (+= c 1)
                (dictSet voiceTracks key voiceTrack)
                (movie.voiceTracks.remove key))
            (doFor =>actor vl movie.voiceLines
                (dictSet voiceLines actor vl))
            (print "scavenge reused ${c}/${t} objects")))

    (function :Appearance appearanceFlag [:Map<String,Bool> map :String key]
        (if (dictGet map key)
                ReAppearance
            {
                (dictSet map key true)
                FirstAppearance
            }))

    (prop &mut :String sceneKey "")
    (method _currentScene [] (dictGet scenes sceneKey))

    (prop &mut :FuzzyMap<String> intercutMap)
    (prop &mut :Map<String,Int> altIdx (new Map))
    (method :Void processIntercut [:Bool skipping :String actorName :Continuation cc]
        (when intercutMap
            (whenLet [sceneForActor (try (dictGet intercutMap actorName) (catch [e] null))]
                (unless (= sceneForActor sceneKey)
                    (setScene skipping sceneForActor cc)
                    (return))))
        (cc))

    (prop :Map<String,Bool> _silentCustomDialogTypes (new Map))
    (savedVar :Bool playVoiceTracksForSilentDialog false)
    (method registerCustomDialogTypeHandler [:String key :CustomDialogTypeHandler<Actor> handler &opt :Bool isSilent]
        (_customDialogTypeHandlers.set key handler)
        (when ?isSilent (dictSet _silentCustomDialogTypes key true)))

    (prop &mut :Void->Void _hideCustomDialog null)
    (var DELAY_BETWEEN_VOICE_TRACKS 0.1)
    (method :Void showDialog [:Bool skipping actorName dialogType wryly text cc &opt :Float voCutoffPercent]
        // Hide custom dialog when the next dialog appears unless HIDECUSTOMDIALOG is called manually:
        (when _hideCustomDialog
            (_hideCustomDialog)
            (set _hideCustomDialog null))
        (dialogHistory.push (Dialog actorName dialogType wryly text))
        (when skipping
            (cc)
            (return))
        (localVar &mut :kiss_tools.TimerWithPause.WrappedTimer cutoffTimer null)
        (processIntercut skipping actorName
            (makeCC cc
                (let [inputDelayKey (inputKey)
                        isSilentType
                            ?(whenLet [(Custom type _ _) dialogType]
                                (_silentCustomDialogTypes.exists type))
                        cc ->:Void
                            {(stopWaitForInput inputDelayKey)
                                (if cutoffTimer
                                        // Don't delay between lines if it's an interruption :)
                                        {
                                            (TimerWithPause.stop cutoffTimer)
                                            (director._hideDialog) (cc)
                                        }
                                    (delay skipping DELAY_BETWEEN_VOICE_TRACKS ->:Void {
                                        (director._hideDialog) (cc)
                                    }))
                                }
                        &mut customCC cc
                        &mut skipCC cc]
                    // Return cc if there is no vo cutoff,
                    // don't if there is (because the end of the track doesn't matter
                    // if it's been interrupted by the next thing already)
                    (localFunction setVoCutoff [start end]
                        (if voCutoffPercent
                                {
                                    (set cutoffTimer
                                        (TimerWithPause.delay
                                            (makeCC cc
                                                (director._hideDialog) (cc))
                                            (* voCutoffPercent (- end start))))
                                    (makeCC null null)
                                }
                            cc))
                    // TODO when "VO for silent dialogue" is enabled play supertext vo
                    // When an actorName is given, check for a voiced line to play.
                    // Otherwise, assume it is un-voiced super text
                    (when (and (or !isSilentType playVoiceTracksForSilentDialog) actorName (< 0 (count voiceTracks)))
                            (case
                                (let [voiceLineKey
                                            (if (voiceLineMatches.exists text)
                                                    .value (voiceLineMatches.get text)
                                                (FuzzyMapTools.bestMatch (dictGet voiceLines actorName) text false))]
                                    (if voiceLineKey
                                            {
                                                (#when debug
                                                    (voiceLineMatches.put text (new JsonString voiceLineKey)))
                                                (dictGet (dictGet voiceLines actorName) voiceLineKey)
                                            }
                                        null))
                                ((objectWith trackKey start end alts)
                                    (case (dictGet altIdx "$actorName $text")
                                        // First time playing, use primary track:
                                        (null
                                            (dictSet altIdx "$actorName $text" 0)
                                            (set customCC ->:Void {})
                                            
                                            (director.playVoiceTrack (dictGet voiceTracks trackKey) 1 start end (setVoCutoff start end)))
                                        // All alts played, loop back to primary track:
                                        ((when (>= idx alts.length) idx)
                                            (dictSet altIdx "$actorName $text" 0)
                                            (set customCC ->:Void {})
                                            (setVoCutoff start end)
                                            (director.playVoiceTrack (dictGet voiceTracks trackKey) 1 start end (setVoCutoff start end)))
                                        // Play an alt
                                        (idx
                                            (let [alt (nth alts idx)
                                                    start alt.start
                                                    end alt.end]
                                                (+= (dictGet altIdx "$actorName $text") 1)
                                                (set customCC ->:Void {})
                                                (setVoCutoff start end)
                                                (director.playVoiceTrack (dictGet voiceTracks trackKey) 1 start end (setVoCutoff start end)))))

                                    (set skipCC ->:Void {(director.stopVoiceTrack (dictGet voiceTracks trackKey)) (cc)}))
                                ((objectWith trackKey start end)
                                    (director.playVoiceTrack (dictGet voiceTracks trackKey) 1 start end (setVoCutoff start end))
                                    (set skipCC ->:Void {(director.stopVoiceTrack (dictGet voiceTracks trackKey)) (cc)}))
                                (otherwise)))

                    (case dialogType
                        ((Custom type character args)
                            (ifLet [handler (dictGet _customDialogTypeHandlers type)]
                                    (let [cleanupFunc (handler actorName character wryly args text skipCC customCC)]
                                        (set _hideCustomDialog cleanupFunc))
                                (throw "No handler for custom dialog type $type")))
                        (otherwise
                            (startWaitForInput skipCC inputDelayKey)
                            (director._showDialog actorName dialogType wryly text skipCC)))))))

    (defMacro withIndexedPath [pathVar typeDefaultDir &body body]
        (#if (or sys hxnodejs)
                `(let [,pathVar
                            (if (StringTools.startsWith ,pathVar assetDir)
                                    ,pathVar
                                (assetPath ,typeDefaultDir ,pathVar))]
                    ,@body)
            body))

    (prop &mut loadedObjects 0)
    (prop &mut loadCalls 0)
    // Methods for loading new assets in a hollywoo movie follow a special naming convention.
    // _add*()  is a method which takes the asset DIRECTLY and adds it to the corresponding asset map.
    //          This is to be used in cases where the asset needs to be loaded specially in a way
    //          the Director's load*() function can't handle.
    // _load*() is a method which takes the asset's PATH and lets the Director load the asset object.
    //
    //          Neither of these is not meant to be called directly, as a precaution against loading new assets
    //          at Movie runtime. However, within the context of (preload...) blocks, they will be
    //          bound to these names:
    // add*()
    // new*()   At which point you can use them. Therefore, if you accidentally try to call new*()
    //          outside of a preload block, your code won't compile.
    //          Which is desired because (preload...) blocks are meant to be allowed at any point in a script,
    //          even following the usage of the assets they load. Runtime loading allows for errors
    //          caused by moving the load calls or asset usages around so the load doesn't precede the usage.
    (method _loadVoiceTrack [actorName :String path :String lineJson]
        (+= loadCalls 1)
        (let [actorNumVoiceTracks (or (dictGet voiceTracksPerActor actorName) 0)
                trackKey "${actorName}${actorNumVoiceTracks}"]
            (cond
                ((voiceTracks.exists trackKey)
                    (dictSet voiceTracksPerActor actorName (+ 1 actorNumVoiceTracks)))
                (true
                    (withIndexedPath path "vo"
                        (+= loadedObjects 1)
                        (_addVoiceTrack actorName (director.loadVoiceTrack path) lineJson))))))

    (method _addVoiceTrack [actorName :VoiceTrack track :String lineJson]
        (assert isLoading)
        (let [actorNumVoiceTracks (or (dictGet voiceTracksPerActor actorName) 0)
                trackKey "${actorName}${actorNumVoiceTracks}"
                :haxe.DynamicAccess<Dynamic> lines (Json.parse lineJson)]
            (dictSet voiceTracksPerActor actorName (+ 1 actorNumVoiceTracks))
            (dictSet voiceTracks trackKey track)
            (doFor =>key line (lines.keyValueIterator)
                (let [:Array<VoiceLine> alts
                            (if line.alts
                                    (for alt (the Array<Dynamic> line.alts) (objectWith [start alt.start end alt.end] trackKey))
                                [])]
                    (unless (voiceLines.existsExactly actorName)
                        (dictSet voiceLines actorName (new FuzzyMap<VoiceLine>)))
                    (dictSet (dictGet voiceLines actorName) key (objectWith [start line.start end line.end] trackKey alts))))))

    (method _noVoiceTracks [actorName]
        (assert isLoading)
        (dictSet voiceTracksPerActor actorName 0)
        (dictSet voiceLines actorName (new FuzzyMap<VoiceLine>)))

    (method _loadProp [name :String path]
        (+= loadCalls 1)
        (unless (props.existsExactly name)
            (withIndexedPath path "images"
                (+= loadedObjects 1)
                (_addProp name (director.loadProp path)))))

    (prop :Array<Array<Dynamic>> propNames [])
    (method :String getPropName [:Prop prop]
        (doFor [_prop name] propNames
            (when (= prop _prop) (return name)))
        (throw "Couldn't get name of prop $prop in $propNames"))

    (method _addProp [name :Prop prop]
        (assert isLoading)
        (dictSet props name prop)
        (propNames.push (dynamicArray prop name)))

    (method _loadSong [name :String path]
        (+= loadCalls 1)
        (unless (songs.existsExactly name)
            (withIndexedPath path "music"
                (+= loadedObjects 1)
                (_addSong name (director.loadSong path)))))

    (method _addSong [name :Song song]
        (assert isLoading)
        (dictSet songs name song))

    (method _loadActor [name :String path]
        (+= loadCalls 1)
        (unless (actors.existsExactly name)
            (withIndexedPath path "images"
                (+= loadedObjects 1)
                (_addActor name (director.loadActor path)))))


    (prop :Array<Array<Dynamic>> actorNames [])
    (method :String getActorName [:Actor actor]
        (doFor [_actor name] actorNames
            (when (= actor _actor) (return name)))
        (throw "Couldn't get name of actor $actor in $actorNames"))

    (method _addActor [name :Actor actor]
        (assert isLoading)
        (dictSet actors name actor)
        (actorNames.push (dynamicArray actor name)))

    (method _loadSet [name :String path]
        (+= loadCalls 1)
        (unless (sets.existsExactly name)
            (withIndexedPath path "images"
                (+= loadedObjects 1)
                (_addSet name (director.loadSet path)))))

    (method _addSet [name :Set set]
        (assert isLoading)
        (dictSet sets name set))

    (method _newSceneFromSet [name :String setKey :SceneTime time :ScenePerspective perspective :Camera camera]
        (assert isLoading)
        (dictSet scenes name (objectWith
                                    [
                                        set
                                            (director.cloneSet (dictGet sets setKey))
                                        characters
                                            (new FuzzyMap<Character<Actor>>)
                                        actorPositionKeys (new FuzzyMap<String>)
                                        propPositionKeys (new FuzzyMap<String>)
                                        propOrder
                                            []
                                        props
                                            (new FuzzyMap<StageProp<Prop>>)
                                        camera
                                            camera
                                    ]
                                    time
                                    perspective)))

    (method _loadSound [name :String path :String description]
        (+= loadCalls 1)
        (unless (sounds.existsExactly name)
            (withIndexedPath path "sounds"
                (+= loadedObjects 1)
                (_addSound name (director.loadSound path) description))))

    (method _addSound [name :Sound s :String description]
        (assert isLoading)
        (dictSet sounds name s)
        (dictSet soundDescriptions name description))

    (method _ccForEachIterator <>[T] [:Iterator<T> iter :(T,Continuation)->Void do_ :Continuation finalCC]
        (withFunctions
            [
                (:Void doNext []
                    (if (iter.hasNext)
                            (do_ (iter.next) doNext)
                        (finalCC)))
            ]
            (doNext)))

    (method _ccForEach <>[T] [:Iterable<T> collection :(T,Continuation)->Void do_ :Continuation finalCC]
        (let [:Iterator<T> iter (collection.iterator)]
            (_ccForEachIterator iter do_ finalCC)))

    (method _hideCurrentScene [:Continuation cc]
        (if sceneKey
                // hide current scene background
                (let [currentScene (dictGet scenes sceneKey)]
                    (director.hideLighting)
                    (director.hideSet currentScene.set currentScene.camera
                        (makeCC cc
                            // hide current scene characters
                            (_ccForEach
                                currentScene.characters
                                ->[:Character<Actor> c :Continuation cc]
                                    (director.hideCharacter c currentScene.camera cc)
                                (makeCC cc
                                    // hide current scene props, etc.
                                    (_ccForEach
                                        currentScene.props
                                        ->[:StageProp<Prop> p :Continuation cc]
                                            (director.hideProp p.prop currentScene.camera cc)
                                        cc))))))
            (cc)))

    (method _updateLighting []
        (director.hideLighting)
        (let [scene (_currentScene)
                sceneKey (FuzzyMapTools.bestMatch scenes sceneKey) // TODO shouldn't this already be a direct match?
                sceneLightSources .elements (lightSources.get sceneKey)
                :Array<LightSource> propLightSources
                    (Lambda.flatten (for =>propKey prop scene.props
                                            (if (lightSources.exists propKey)
                                                    (for ls .elements (lightSources.get propKey)
                                                        (director.offsetLightSource ls prop.position))
                                                [])))
                :Array<LightSource> actorLightSources
                    (Lambda.flatten (for =>actorKey character scene.characters
                                            (if (lightSources.exists actorKey)
                                                    (for ls .elements (lightSources.get actorKey)
                                                        (director.offsetLightSource ls character.stagePosition))
                                                [])))
                :Array<LightSource> allLightSources
                    (Lambda.flatten
                        [
                            sceneLightSources
                            propLightSources
                            actorLightSources
                        ])]
            (director.showLighting scene.time allLightSources scene.camera)))

    (method _showScene [:Scene<Set,Actor,Prop,Camera> scene :Appearance appearance :Camera camera :Continuation cc]
        
        // Show current scene background
        (director.showSet scene.set scene.time scene.perspective appearance camera
            (makeCC cc
                // Show current scene characters
                (_ccForEach
                    (object iterator ->(scene.characters.keys))
                    ->[:String key :Continuation cc]
                        (director.showCharacter (dictGet scene.characters key) (appearanceFlag shownCharacters key) camera cc)
                    (makeCC cc
                        // show current scene props, etc.
                        (_ccForEach
                            scene.propOrder
                            ->[:String propKey :Continuation cc]
                                (let [p (dictGet scene.props propKey)]
                                    (director.showProp p.prop p.position ReAppearance .camera (_currentScene) cc))
                            cc))))))

    (prop &mut :Bool paused false)
    (prop &mut :Continuation onComplete null)

    (method pause []
        (unless paused
            (TimerWithPause.pause)
            (set paused true)
            (director.pause)))

    (method resume []
        (when paused
            (set paused false)
            (director.resume)
            (TimerWithPause.resume)))

    (prop &mut promptedRecording false)
    (method promptToRecord [:Continuation cc]
        (unless kiss_tools.OBSTools.obsIsRecording
            (director.chooseString
                "Start recording?"
                ["Yes" "No"]
                ->:Void choice
                    (case choice
                        ("Yes"
                            (set promptedRecording true)
                            (director.prepareForRecording)
                            (kiss_tools.OBSTools.startObs)
                            (cc))
                        (otherwise (cc))))))

    (method stopPromptedRecording []
        (set promptedRecording (and promptedRecording kiss_tools.OBSTools.obsIsRecording))
        (when promptedRecording
            (kiss_tools.OBSTools.stopObs)
            (set promptedRecording false)))


    (prop :Map<String,Array<String>> positionsInScene (new Map))
    (method :StagePosition resolvePosition [:Dynamic position :Null<PositionHolder> holder]
        (typeCase [position]
            ([:String positionKey]
                (assert sceneKey "resolvePosition() should be called in the context of a scene")
                (let [positionsInThisScene (dictGet positionsInScene sceneKey)]
                    (unless (positionsInThisScene.contains positionKey)
                        (positionsInThisScene.push positionKey)))
                // Store a record in the scene of which actors/props are using which position keys:
                (case holder
                    ((Actor actor) (dictSet .actorPositionKeys (_currentScene) actor positionKey))
                    ((Prop prop) (dictSet .propPositionKeys (_currentScene) prop positionKey))
                    (null null))

                (let [pos (stagePositions.get positionKey)]
                    (ifLet [relativeKey .value (positionRelativity.get positionKey)
                                anchorPos (resolvePosition relativeKey null)]
                            (new StagePosition #{anchorPos.x + pos.x;}# #{anchorPos.y + pos.y;}# #{anchorPos.z + pos.z;}#)
                        pos)))
            ([:StagePosition position]
                position)
            (otherwise (throw "Not a position or position key: $position"))))

    (prop &mut :Map<String,Continuation> loopingSoundPlays (new Map))

    (#when (or sys hxnodejs)
        (prop :FuzzyMap<FuzzyMap<String>> assetPaths (new FuzzyMap))
        (prop &mut :String assetDir "")
        (prop :Array<Array<String>> loadedCredits [])
        (method _indexAssetPaths [:String assetDir]
            (set this.assetDir assetDir)
            (let [dirParts (assetDir.split "/")]
                (doFor part dirParts
                    (dictSet assetPaths part (new FuzzyMap))))
            (walkDirectory "" assetDir
                ->file (ifLet [[:: ...dirs basename] (file.split "/")
                                    ext (Path.extension file)
                                    noExt (Path.withoutExtension file)
                                    overrideEndings [
                                        "Edited"
                                        "-edited"
                                    ]
                                    overrideExtensions [
                                        "$ext"
                                        "png" // It's common to edit a jpg into a png
                                        "wav" // or an ogg into a wav
                                        "ogg" // or an mp3 into an ogg
                                    ]
                                    overridePath file]
                                {
                                    (cond
                                        ((= ext "tsv")
                                            // If an asset's source is neither pixabay or unsplash (public domain),
                                            // make some noise if you forgot to include its license in a file:
                                            (let [content (sys.io.File.getContent file)
                                                    source (.shift (content.split "\t"))
                                                    sourceUrl (.pop (content.split "\t"))]
                                                (case source
                                                    ("pixabay.com" null)
                                                    ("unsplash.com" null)
                                                    ("openclipart.org" null)
                                                    ("pixnio.com" null)
                                                    (otherwise
                                                        (#when debug
                                                            (unless (sys.FileSystem.exists "${noExt}.LICENSE.txt")
                                                                (print "Warning! License file may be required for redistributing $file from $sourceUrl")))))))
                                        (true
                                            (doFor [ending extension] (intersect overrideEndings overrideExtensions)
                                                (let [possibleOverride "${noExt}${ending}.${extension}"]
                                                    (when (sys.FileSystem.exists possibleOverride)
                                                        (#when debug
                                                            (print "$file overridden by $possibleOverride"))
                                                        (set overridePath possibleOverride)
                                                        (break))))))
                                    (doFor dir dirs
                                        (dictSet (dictGet assetPaths dir) basename overridePath))
                                }
                            (print "Warning: asset $file cannot be indexed"))
                ->folderToFilter (assertLet [[:: ... dir] (folderToFilter.split "/")]
                                    (unless (assetPaths.existsExactly dir)
                                        (dictSet assetPaths dir (new FuzzyMap)))
                                    false)))

        (method assetPath [directory filename]
            (let [dirMap (dictGet assetPaths directory)
                    basename (FuzzyMapTools.bestMatch dirMap filename)
                    noExt (Path.withoutExtension basename)
                    tsv "${noExt}.tsv"]
                (if (dirMap.existsExactly tsv)
                        (let [tsvContent (sys.io.File.getContent (dictGet dirMap tsv))]
                            (loadedCredits.push (tsvContent.split "\t")))
                    (#when debug (print "Warning: no credit tsv file for ${directory}/${filename}")))
                (dictGet dirMap basename))))

    (function choosePlayMode [:Director<Dynamic,Dynamic,Dynamic,Dynamic,Dynamic,Dynamic,Dynamic,Dynamic> director :Void->Void cc]
        (director.chooseString
            "Choose a Play Mode\n\nThe Play Mode setting determines how the story will flow forward.\n\nRead mode lets you go at your own pace, stopping after most dialogue until you choose to continue.\n\nWatch mode proceeds automatically like a cutscene or a movie.\n\nYou can still skip dialogue or speed up animations in either mode.\n\nYou can change your decision any time in the Options menu.\n\n"
            ["Read Mode" "Watch Mode (Recommended)"]
            ->:Void mode {
                (case mode
                    ("Read Mode"
                        (set Movie.playMode Read))
                    ("Watch Mode (Recommended)"
                        (set Movie.playMode Watch))
                    (never otherwise))
                ~Movie.playMode

                (when director.movie
                    (set director.movie.delayHandling
                        (case hollywoo.Movie.playMode
                            (Read Manual)
                            (Watch AutoWithSkip)
                            (never otherwise))))

                (cc)
            }))

    (defNew
        [
            // "View" in the Model-View-Controller architecture:
            &prop :Director<Set,Actor,Sound,Song,Prop,VoiceTrack,Camera,LightSource> director
            :String lightSourceJsonFile
            :LightSource defaultLightSource
            :String stagePositionsJson
            :String delayLengthsJson
            :String voiceLineMatchesJson
            :String miscFloatJson
            :String miscIntJson
            :String positionRelativityJson
        ]
        [
            :JsonMap<StagePosition> stagePositions
                (new JsonMap stagePositionsJson (new StagePosition 0 0 0))
            :JsonMap<JsonArray<LightSource>> lightSources
                (new JsonMap lightSourceJsonFile (new JsonArray [] defaultLightSource))
            :JsonMap<JsonFloat> delayLengths
                (new JsonMap delayLengthsJson (new JsonFloat 0.5))
            :JsonStringMap voiceLineMatches
                (new JsonMap voiceLineMatchesJson (new JsonString ""))
            :JsonMap<JsonFloat> miscFloats
                (new JsonMap miscFloatJson (new JsonFloat 0))
            :Map<String,Float->Void> miscFloatChangeEvents (new Map)
            :JsonMap<JsonInt> miscInts
                (new JsonMap miscIntJson (new JsonInt 0))
            :Map<String,Int->Void> miscIntChangeEvents (new Map)
            :JsonStringMap positionRelativity
                (new JsonMap positionRelativityJson (new JsonString ""))
            :Map<String,String> sceneMusic (new Map)
            :Map<String,Float> sceneMusicVolume (new Map)
            &mut :String playingSceneMusic null
            &mut :Continuation->Void lastCommand ->:Void cc (cc)
        ]
        (super)
        (set director.movie this)
        (set onSkipEnd
            ->:Void {
                (doFor play loopingSoundPlays
                    (play))
                (when currentSong
                    (playSong false currentSong ->:Void {} currentSongVolumeMod currentSongLooping false))
            })

        // this allows processes to use the handler,
        // but when they have their windows open, doingSomething won't let
        // other shortcuts cause a problem.
        // Just remember to have wrap new processes in (unless doingSomething (set doingSomething true) <...>)
        (prop &mut doingSomething false)

        (let [shortcutHandler (director.shortcutHandler)
                redefineNormalShortcuts ->{
                    (shortcutHandler.registerItem "{escape} Pause the movie"
                        ->cc (unless doingSomething (set doingSomething true)
                                (director.showPauseMenu cc)) true)
                    (shortcutHandler.registerItem "{tab} show dialog history"
                        ->cc (unless doingSomething (set doingSomething true)
                            (director.showDialogHistory
                                (if (> dialogHistory.length MAX_DIALOG_HISTORY)
                                        (dialogHistory.slice (- dialogHistory.length MAX_DIALOG_HISTORY))
                                    dialogHistory) cc)) true)
                }
                cc ->{
                    (set doingSomething false)
                    (redefineNormalShortcuts)
                    (resume)
                }]
            (set shortcutHandler.onSelectItem
                ->process {
                    (pause)
                    (shortcutHandler.start)
                    (process cc)
                })
            (set shortcutHandler.onBadKey
                ->[_ _]
                    (when shortcutHandler.currentMap
                        (shortcutHandler.start)))
            (redefineNormalShortcuts)
            (#when debug
                (shortcutHandler.registerItem "[.] repeat last command"
                    ->cc
                        (unless doingSomething (set doingSomething true)
                            (lastCommand cc)))

                (localFunction redefineLastDelay [cc]
                    (when doingSomething (return))
                    (set doingSomething true)
                    (set lastCommand redefineLastDelay)
                    (if lastDelay
                            (director.enterString "Redefine $lastDelay from $lastDelayLength sec?"
                                ->lengthStr
                                    (let [length (Std.parseFloat lengthStr)]
                                        (if (Math.isNaN length)
                                                (print "Failed to parse ${lengthStr}. leaving value the same")
                                            (delayLengths.put lastDelay (new JsonFloat length)))
                                        (cc)))
                        {
                            (print "no delay to redefine")
                            (cc)
                        }))
                (shortcutHandler.registerItem "[d]efine [d]elay" redefineLastDelay)

                (prop CANCEL_COMMAND "CANCEL CHOICE")
                (method withCancel [choices]
                    (.concat [CANCEL_COMMAND] choices))

                (shortcutHandler.registerItem "[d]efine [m]isc [i]nt"
                    ->cc
                        (unless doingSomething (set doingSomething true)
                            (director.chooseString "Which misc int?" (withCancel (collect (miscInts.keys)))
                                (unlessCancel key
                                    (withFunctions
                                        [
                                            (defineMiscInt [cc]
                                                (director.enterString "Redefine $key from ${.value (miscInts.get key)}?"
                                                    ->valStr
                                                        (let [v (Std.parseInt valStr)]
                                                            (if (= v null)
                                                                    (print "Failed to parse ${valStr}. leaving value the same")
                                                                {
                                                                    (miscInts.put key (new JsonInt v))
                                                                    (ifLet [onChange (dictGet miscIntChangeEvents key)]
                                                                        (onChange v))
                                                                })

                                                            (cc))))
                                        ]
                                        (set lastCommand defineMiscInt)
                                        (defineMiscInt cc))))))

                (shortcutHandler.registerItem "[d]efine [m]isc [f]loat"
                    ->cc
                        (unless doingSomething (set doingSomething true)
                            (director.chooseString "Which misc float?" (withCancel (collect (miscFloats.keys)))
                                (unlessCancel key
                                    (withFunctions
                                        [
                                            (defineMiscFloat [cc]
                                                (director.enterString "Redefine $key from ${.value (miscFloats.get key)}?"
                                                    ->valStr
                                                        (let [v (Std.parseFloat valStr)]
                                                            (if (Math.isNaN v)
                                                                    (print "Failed to parse ${valStr}. leaving value the same")
                                                                {
                                                                    (miscFloats.put key (new JsonFloat v))
                                                                    (ifLet [onChange (dictGet miscFloatChangeEvents key)]
                                                                        (onChange v))
                                                                })
                                                            (cc))))
                                        ]
                                        (set lastCommand defineMiscFloat)
                                        (defineMiscFloat cc))))))

                (shortcutHandler.registerItem "[d]efine [p]osition"
                    ->cc
                        (unless doingSomething (set doingSomething true)
                            (director.chooseString "Which position?" (withCancel (dictGet positionsInScene sceneKey))
                                (unlessCancel positionKey
                                    (withFunctions
                                        [
                                            (defineStagePosition [cc]
                                                (director.defineStagePosition
                                                    .camera (_currentScene)
                                                    ->[:StagePosition position] {
                                                        // store it relative:
                                                        (stagePositions.put positionKey
                                                            (ifLet [relativeKey .value (positionRelativity.get positionKey)
                                                                        anchorPos (resolvePosition relativeKey null)]
                                                                    (new StagePosition (- position.x anchorPos.x) (- position.y anchorPos.y) (- position.z anchorPos.z))
                                                                position))
                                                        // Reposition actors and props on the fly
                                                        (let [scene (_currentScene)
                                                                characterIterator (scene.characters.keys)
                                                                propOrder (scene.propOrder.copy)]
                                                            (withFunctions
                                                                [
                                                                    (nextProp []
                                                                        (ifLet [key (propOrder.shift)
                                                                                    prop (dictGet scene.props key)]
                                                                                (director.hideProp prop.prop scene.camera
                                                                                    (makeCC nextProp
                                                                                        (when (scene.propPositionKeys.exists key)
                                                                                            (set prop.position (resolvePosition (dictGet scene.propPositionKeys key) null)))
                                                                                        (director.showProp prop.prop prop.position ReAppearance scene.camera nextProp)))
                                                                            {
                                                                                (_updateLighting)
                                                                                (cc)
                                                                            }))
                                                                    (nextCharacter []
                                                                        (if (characterIterator.hasNext)
                                                                                (let [key (characterIterator.next)
                                                                                        character (dictGet scene.characters key)]
                                                                                    (director.hideCharacter character scene.camera
                                                                                        (makeCC nextCharacter
                                                                                            (when (scene.actorPositionKeys.exists key)
                                                                                                (set character.stagePosition (resolvePosition (dictGet scene.actorPositionKeys key) null)))
                                                                                            (director.showCharacter character ReAppearance scene.camera nextCharacter))))
                                                                            (nextProp)))
                                                                ]
                                                                (nextCharacter)))
                                                    }
                                                    (resolvePosition positionKey null)))
                                        ]
                                        (set lastCommand defineStagePosition)
                                        (defineStagePosition cc))))))

                (shortcutHandler.registerItem "[d]efine [r]elativity of position"
                    ->cc
                        (unless doingSomething (set doingSomething true)
                            (director.chooseString "Which position?" (withCancel (dictGet positionsInScene sceneKey))
                                (unlessCancel positionKey
                                    (withFunctions
                                        [
                                            (defineRelativity [cc]
                                                (director.chooseString "Make relative to which position?"
                                                                        (let [keys (.copy (dictGet positionsInScene sceneKey))]
                                                                            (keys.remove positionKey)
                                                                            (withCancel keys))
                                                                        (unlessCancel relativeKey
                                                                            (let [pos (resolvePosition positionKey null)
                                                                                    anchorPos (resolvePosition relativeKey null)]
                                                                                (positionRelativity.put positionKey (new JsonString relativeKey))
                                                                                (stagePositions.put positionKey
                                                                                    (new StagePosition (- pos.x anchorPos.x) (- pos.y anchorPos.y) (- pos.z anchorPos.z)))))))
                                        ]
                                        (set lastCommand defineRelativity)
                                        (defineRelativity cc))))))

                (localFunction defineLightSource [cc]
                    (when doingSomething (return))
                    (set doingSomething true)
                    (set lastCommand defineLightSource)
                    (director.defineLightSource
                        ->[:LightSource source] {
                            (let [arr (lightSources.get sceneKey)]
                                (arr.elements.push source)
                                (lightSources.put sceneKey arr)
                                (director.hideLighting)
                                (director.showLighting .time (_currentScene) arr.elements .camera (_currentScene))
                                (cc))
                        }))
                (shortcutHandler.registerItem "[d]efine [l]ight source" defineLightSource)

                (localFunction removeLightSource [cc]
                    (when doingSomething (return))
                    (set doingSomething true)
                    (set lastCommand removeLightSource)
                    (let [arr (lightSources.get sceneKey)
                            stringArr (for ls arr (ls.stringify))
                            stringMap (for [key ls] (zipThrow stringArr arr) =>key ls)]
                        (director.chooseString "Remove which light source?" (withCancel stringArr)
                            (unlessCancel choice
                                (let [ls (dictGet stringMap choice)]
                                    (arr.elements.remove ls)
                                    (lightSources.put sceneKey arr)
                                    (director.hideLighting)
                                    (director.showLighting .time (_currentScene) arr.elements .camera (_currentScene))
                                    (cc))))))
                (shortcutHandler.registerItem "[r]emove [l]ight source" removeLightSource)

                (localFunction connectLightSourceToProp [cc]
                    (when doingSomething (return))
                    (set doingSomething true)
                    (set lastCommand connectLightSourceToProp)
                    (let [arr (lightSources.get sceneKey)
                            stringArr (for ls arr (ls.stringify))
                            stringMap (for [key ls] (zipThrow stringArr arr) =>key ls)]
                        (director.chooseString "Connect which light source?" (withCancel stringArr)
                            (unlessCancel choice
                                (let [ls (dictGet stringMap choice)
                                        propsArr (collect (.keys .props (_currentScene)))]
                                    (director.chooseString "Connect to which prop?" (withCancel propsArr)
                                        (unlessCancel propChoice
                                            (let [prop (dictGet .props (_currentScene) propChoice)
                                                    relativeLS
                                                        // Make the light source's positions relative to the chosen prop
                                                        (director.offsetLightSource ls (opposite prop.position))
                                                    propLightSources
                                                        (lightSources.get propChoice)]
                                                // Remove light source from the scene
                                                (arr.elements.remove ls)
                                                (lightSources.put sceneKey arr)
                                                
                                                // store it in light sources with the prop's key
                                                (propLightSources.elements.push relativeLS)
                                                (lightSources.put propChoice propLightSources)
                                                (_updateLighting)
                                                (cc)))))))))
                (shortcutHandler.registerItem "[c]onnect [l]ight source to [p]rop" connectLightSourceToProp)

                (localFunction connectLightSourceToActor [cc]
                    (when doingSomething (return))
                    (set doingSomething true)
                    (set lastCommand connectLightSourceToActor)
                    (let [arr (lightSources.get sceneKey)
                            stringArr (for ls arr (ls.stringify))
                            stringMap (for [key ls] (zipThrow stringArr arr) =>key ls)]
                        (director.chooseString "Connect which light source?" (withCancel stringArr)
                            (unlessCancel choice
                                (let [ls (dictGet stringMap choice)
                                        actorArr (collect (.keys .characters (_currentScene)))]
                                    (director.chooseString "Connect to which actor?" (withCancel actorArr)
                                        (unlessCancel actorChoice
                                            (let [character (dictGet .characters (_currentScene) actorChoice)
                                                    relativeLS
                                                        // Make the light source's positions relative to the chosen character
                                                        (director.offsetLightSource ls (opposite character.stagePosition))
                                                    actorLightSources
                                                        (lightSources.get actorChoice)]
                                                // Remove light source from the scene
                                                (arr.elements.remove ls)
                                                (lightSources.put sceneKey arr)
                                                
                                                // store it in light sources with the prop's key
                                                (actorLightSources.elements.push relativeLS)
                                                (lightSources.put actorChoice actorLightSources)
                                                (_updateLighting)
                                                (cc)))))))))
                (shortcutHandler.registerItem "[c]onnect [l]ight source to [a]ctor" connectLightSourceToActor))))

    @:keep
    (method :Void _strobe [:Bool skipping :Bool prop :String actorOrPropKey :Float strobeSec :Int times &opt :Continuation cc]
        (when skipping
            (when cc
                (cc))
            (return))

        (let [&mut :Dynamic propOrCharacter
                    // dictGet on a fuzzymap will function as an assertion that the prop or character is already added,
                    // but a try-catch here could make that more clear
                    (if prop
                            (dictGet .props (_currentScene) actorOrPropKey)
                        (dictGet .characters (_currentScene) actorOrPropKey))
                appearance ReAppearance
                camera .camera (_currentScene)
                &mut shown true
                :Function show
                    (if prop
                            (let [_prop propOrCharacter.prop
                                    _position propOrCharacter.position]
                                (set propOrCharacter _prop)
                                (director.showProp.bind _ _position))
                        director.showCharacter)
                :Function hide
                    (if prop
                            director.hideProp
                        director.hideCharacter)]
            (TimerWithPause.interval
                ->:Void
                    (if shown
                            {
                                (hide propOrCharacter camera ->:Void {})
                                (set shown false)
                            }
                        {
                            (show propOrCharacter appearance camera ->:Void {})
                            (set shown true)
                        })
                strobeSec
                (* times 2))
            (when cc
                (TimerWithPause.delay cc (* strobeSec 2 (+ 1 times))))))

    (method :Void handleCaption [:Bool skipping :String name]
        (when showCaptions
            (whenLet [desc (dictGet soundDescriptions name)
                        id captionId++
                        sound (dictGet sounds name)]
                (director.showCaption desc id)
                (delay skipping (min MAX_CAPTION_DURATION (director.getSoundLength sound))
                    (makeCC null
                        (director.hideCaption id))) true)))

    (method :Int miscInt [:String key &opt :Int defaultVal :Int->Void onChange]
        (when onChange
            (dictSet miscIntChangeEvents key onChange))
        (if (miscInts.exists key)
                .value (miscInts.get key)
            {
                (when defaultVal
                    (miscInts.put key (new JsonInt defaultVal)))
                defaultVal
            }))

    (method :Float miscFloat [:String key &opt :Float defaultVal :Float->Void onChange]
        (when onChange
            (dictSet miscFloatChangeEvents key onChange))
        (if (miscFloats.exists key)
                .value (miscFloats.get key)
            {
                (when defaultVal
                    (miscFloats.put key (new JsonFloat defaultVal)))
                defaultVal
            }))

    (method :Float resolveDelay [:Dynamic lengthOrKey]
        (typeCase [lengthOrKey]
            ([:Float sec] sec)
            ([:String key]
                (let [lengthFloat .value (delayLengths.get key)]
                    (set lastDelay key)
                    (set lastDelayLength lengthFloat)
                    lengthFloat))
            (never otherwise)))

    (method inputKey []
        (uuid.Uuid.v4))

    (prop &mut currentInputKey "")
    (method :String startWaitForInput [:Continuation cc &opt :String key]
        (when currentInputKey
            (director._stopWaitForInput))
        (unless key
            (set key (inputKey)))
        (set currentInputKey key)
        (director._startWaitForInput ->(unless doingSomething (cc)))
        key)

    (method stopWaitForInput [:String key]
        (when (= currentInputKey key)
            (director._stopWaitForInput))))

// END Parent class definitions

(defMacro indexAssetPaths [dir]
    `(preload
        (_indexAssetPaths ,dir)))

(defMacro mode [mode &body body]
    `(case Movie.playMode
        (,mode ,@body)
        (otherwise (cc))))

(defMacroVar avoidDuplicateDefinition true)
// Some real magic happens here. This macro defines a method, AND a reader macro
// for calling it with skipping and cc passed automatically if cc is an argument.
// GOTCHA: DO NOT use (method) directly in this file outside of the above #unless subclass block!!
(defMacro hollywooMethod [nameAndType argList &builder b &body body]
    (let [args (expList argList)
            numArgs args.length
            methodName (symbolNameValue nameAndType true)
            &mut readerMacroStart "$(.toUpperCase methodName) "
            argSymbolNames (for arg args (symbolNameValue arg true true))]
        (when (apply and (for name argSymbolNames !(= -1 (.indexOf ["cc" "skipping"] name)))) (set readerMacroStart (StringTools.trim readerMacroStart)))
        `{
            (defReaderMacro ,readerMacroStart [stream &builder b]
                (let [nextLineStream
                            (stream.expect "hollywoo macro line" ->(stream.takeLineAsStream))
                        methodCall
                            (b.callSymbol
                                ,methodName
                                ,(for arg args
                                    (cond
                                        ((= "cc" (symbolNameValue arg true true))
                                            (b.callSymbol "b.symbol" [(b.str "cc")]))
                                        ((= "skipping" (symbolNameValue arg true true))
                                            (b.callSymbol "b.symbol" [(b.str "skipping")]))
                                        (true
                                            (b.callSymbol "readOr"
                                                [
                                                    (b.symbol "nextLineStream")
                                                    // optional arguments may not be present:
                                                    (b.callSymbol "b.symbol" [(b.str "null")])
                                                ])))))]
                    methodCall))
            (#when (or !subclass !avoidDuplicateDefinition) @:keep (method ,nameAndType ,argList ,@body))
        }))

(hollywooMethod :Void restorePlayMode [:Continuation cc]
    (set delayHandling
        (case hollywoo.Movie.playMode
            (Read Manual)
            (Watch AutoWithSkip)
            (never otherwise)))
    (cc))

(hollywooMethod :Void overridePlayMode [:PlayMode mode :Continuation cc]
    (set delayHandling
        (case mode
            (Read Manual)
            (Watch AutoWithSkip)
            (never otherwise)))
    (cc))

(hollywooMethod :Void hideCustomDialog [:Continuation cc]
    (when _hideCustomDialog
        (_hideCustomDialog)
        (set _hideCustomDialog null))
    (cc))

(hollywooMethod :Void delay [:Bool skipping :Dynamic length :Continuation cc &opt :Bool dontWaitForInput]
    (when skipping
        (cc)
        (return))
    (let [sec (resolveDelay length)
            key (inputKey)]
        (case [delayHandling ?dontWaitForInput]
            ([Auto _]
                (TimerWithPause.delay cc sec))
            ((or [AutoWithSkip _] [Manual true])
                (let [autoDelay
                            (TimerWithPause.delay
                                ->{
                                    (unless dontWaitForInput
                                        (stopWaitForInput key))
                                    (cc)
                                }
                                sec)]
                    (unless dontWaitForInput
                        (startWaitForInput
                            ->{
                                (stopWaitForInput key)
                                (TimerWithPause.stop autoDelay)
                                (cc)
                            }
                            key))))
            ([Manual false]
                (director.showInputIcon)
                (startWaitForInput
                    ->{
                        (director.hideInputIcon)
                        (stopWaitForInput key)
                        (cc)
                    }
                    key))
            (otherwise (throw "Unsupported delay type $delayHandling")))))

(hollywooMethod :Void watchModeDelay [:Bool skipping :Dynamic length :Continuation cc]
    (mode Watch (delay skipping length cc)))

(hollywooMethod setSceneSong [:String scene :String songKey &opt :Float volumeMod :Continuation cc]
    (dictSet sceneMusic scene songKey)
    (dictSet sceneMusicVolume scene volumeMod)
    (when cc (cc)))

(hollywooMethod setCurrentSceneSong [:Bool skipping :String songKey :Continuation cc &opt :Float volumeMod]
    (dictSet sceneMusic sceneKey songKey)
    (dictSet sceneMusicVolume sceneKey volumeMod)
    (cond
        ((= playingSceneMusic songKey)
            (changeSongVolume skipping volumeMod cc))
        (true
            (set playingSceneMusic songKey)
            (stopSong skipping (makeCC null null))
            (loopSong skipping songKey (makeCC null null) volumeMod)
            (cc))))

(hollywooMethod setScene [:Bool skipping :String name :Continuation cc]
    (hideCustomDialog
        (makeCC cc
            (_hideCurrentScene
                (makeCC cc
                    (let [name (FuzzyMapTools.bestMatch scenes name)]
                        (set sceneKey name)
                        (ifLet [songKey (dictGet sceneMusic name)]
                                    // Keep the song going if it's the same as current. Otherwise, take over!
                                    (unless (= playingSceneMusic songKey)
                                        (set playingSceneMusic songKey)
                                        (stopSong skipping (makeCC null null))
                                        (loopSong skipping songKey (makeCC null null) (dictGet sceneMusicVolume name)))
                            (when playingSceneMusic
                                (set playingSceneMusic null)
                                (stopSong skipping (makeCC null null))))
                        (unless (positionsInScene.exists sceneKey)
                            (dictSet positionsInScene sceneKey []))
                        (_showScene
                            (dictGet scenes name)
                            (appearanceFlag shownScenes name)
                            .camera (dictGet scenes name)
                            cc)))))))

// Switch scenes but bring all the characters and props from the current one
(hollywooMethod moveToScene [:Bool skipping :String name :Continuation cc]
    (case (_currentScene)
        ((objectWith characters props propOrder actorPositionKeys propPositionKeys)
            (let [characters (characters.copy)
                    props (props.copy)
                    propOrder (propOrder.copy)
                    actorPositionKeys (actorPositionKeys.copy)
                    propPositionKeys (propPositionKeys.copy)]
                (clearCharacters
                    (makeCC cc
                        (clearProps
                            (makeCC cc
                                (setScene skipping name
                                    (makeCC cc
                                        (_ccForEachIterator (characters.keyValueIterator)
                                            ->[character cc]
                                                (addCharacter character.key character.value.stagePosition character.value.stageFacing cc)
                                            (makeCC cc
                                                (_ccForEach propOrder
                                                    ->[propKey cc]
                                                        (addProp propKey .position (props.get propKey) cc)
                                                    (makeCC cc
                                                        (doFor =>actor posKey actorPositionKeys
                                                            (dictSet .actorPositionKeys (_currentScene) actor posKey))
                                                        (doFor =>prop posKey propPositionKeys
                                                            (dictSet .propPositionKeys (_currentScene) prop posKey))
                                                        (cc)))))))))))))
        (never otherwise)))

(hollywooMethod playSound [:Bool skipping :String name :Continuation cc &opt :Float volumeMod :Bool waitForEnd :Bool dontWaitForInput]
    (set volumeMod (or volumeMod 1))
    (assert (<= 0 volumeMod 1))
    (let [name (FuzzyMapTools.bestMatch sounds name)]
        (localVar looping ?(dictGet loopingSoundPlays name))
        (whenLet [desc (dictGet soundDescriptions name)]
            (dialogHistory.push (Sound desc)))
        (when skipping
            (cc)
            (return))
        (unless looping
            (handleCaption skipping name))
        (let [sound (dictGet sounds name)
                inputDelayKey (inputKey)]
            (withFunctions
                [
                    (:Void innerCC []
                        (unless looping
                            (director.stopSound sound)
                            (unless dontWaitForInput
                                (stopWaitForInput inputDelayKey)))
                        (cc))
                ]
                (unless (or looping dontWaitForInput)
                    (when waitForEnd
                        (startWaitForInput innerCC inputDelayKey)))
                (director.playSound sound volumeMod (when waitForEnd innerCC))))
        (unless waitForEnd
            (cc))))

(hollywooMethod awaitPlaySound [:Bool skipping :String name :Continuation cc &opt :Float volumeMod]
    (playSound skipping name cc volumeMod true))

(hollywooMethod awaitPlaySounds [:Bool skipping :Array<String> names :Continuation cc &opt :Float volumeMod]
    (let [names (names.copy)
            inputDelayKey (inputKey)]
        (localVar &mut currentSound "")
        (localVar endCC
            (makeCC cc
                (stopWaitForInput inputDelayKey)
                (whileLet [soundKey (names.shift)]
                    // This just adds the sounds to the history:
                    (playSound true soundKey (makeCC null null) volumeMod false true))
                (when currentSound
                    (stopSound skipping currentSound cc))
                (cc)))
        (when skipping
            (endCC)
            (return))
        (startWaitForInput endCC inputDelayKey)
        (_ccForEach names
            ->[name cc]
                {
                    (set currentSound name)
                    (playSound skipping name cc volumeMod true true)
                }
            endCC)))

(hollywooMethod stopSound [:Bool skipping :String name :Continuation cc]
    (let [name (FuzzyMapTools.bestMatch sounds name)]
        (loopingSoundPlays.remove name)
        (unless skipping
            (director.stopSound (dictGet sounds name))))
    (cc))

(hollywooMethod loopSound [:Bool skipping :String name :Continuation cc &opt :Float volumeMod]
    // Even when skipping, create a lambda that plays an iteration of the sound,
    // so if skipping ends and the sound is still supposed to be looping,
    // we can start it!
    (let [name (FuzzyMapTools.bestMatch sounds name)]
        (withFunctions
            [
                (:Void playAgain []
                    (playSound false name
                        (makeCC null
                            (when (loopingSoundPlays.exists name)
                                (playAgain)))
                        volumeMod
                        true))
            ]
            (handleCaption skipping name)
            (dictSet loopingSoundPlays name playAgain)
            (unless skipping
                (playAgain))))
    (cc))

(hollywooMethod playSong [:Bool skipping :String name :Continuation cc &opt :Float volumeMod :Bool loop :Bool waitForEnd]
    (set volumeMod (or volumeMod 1))
    (assert (<= 0 volumeMod 1))
    (set currentSong (FuzzyMapTools.bestMatch songs name))
    (set currentSongVolumeMod volumeMod)
    (set currentSongLooping ?loop)
    (when skipping
        (cc)
        (return))
    (director.playSong (dictGet songs currentSong) volumeMod ?loop ?waitForEnd cc))

(hollywooMethod changeSongVolume [:Bool skipping :Float volumeMod :Continuation cc]
    (set currentSongVolumeMod volumeMod)
    (when skipping
        (cc)
        (return))
    (director.changeSongVolume volumeMod cc))

(hollywooMethod awaitPlaySong [:Bool skipping :String name :Continuation cc &opt :Float volumeMod]
    (when skipping
        (cc)
        (return))
    (playSong skipping name cc volumeMod false true))

(hollywooMethod loopSong [:Bool skipping :String name :Continuation cc &opt :Float volumeMod]
    (playSong skipping name cc volumeMod true false))

(hollywooMethod stopSong [:Bool skipping cc]
    (set currentSong "")
    (unless skipping
        (director.stopSong))
    (cc))

(hollywooMethod autoZProcess [:StagePosition position :Continuation cc]
    // handle auto z recursively
    (ifLet [(Some (objectWith zPerLayer frontLayer)) (director.autoZConfig)]
            {
                (doFor =>name otherCharacter .characters (_currentScene)
                    (when (and (= position.x otherCharacter.stagePosition.x) (= position.y otherCharacter.stagePosition.y) (= position.z otherCharacter.stagePosition.z))
                        (moveCharacter name (new StagePosition position.x position.y (+ otherCharacter.stagePosition.z zPerLayer)) otherCharacter.stageFacing cc)
                        (return)))
                (cc)
            }
        (cc)))

(hollywooMethod addCharacter [actorName :Dynamic position :StageFacing facing :Continuation cc]
    (let [actorName (FuzzyMapTools.bestMatch actors actorName)
            position (resolvePosition position (Actor actorName))
            character (object stagePosition position stageFacing facing actor (dictGet actors actorName))]
        (autoZProcess position
            (makeCC cc
                (dictSet .characters (_currentScene) actorName character)
                (_updateLighting)
                (director.showCharacter
                    character
                    (appearanceFlag shownCharacters actorName)
                    .camera (_currentScene)
                    cc)))))

(hollywooMethod removeCharacter [actorName :Continuation cc]
    (let [c (dictGet .characters (_currentScene) actorName)]
        (.remove .characters (_currentScene) actorName)
        (_updateLighting)
        (director.hideCharacter c .camera (_currentScene) cc)))

(hollywooMethod clearCharacters [:Continuation cc]
    (doFor =>name c .characters (_currentScene)
        (director.hideCharacter c .camera (_currentScene) (makeCC null null))
        (.remove .characters (_currentScene) name))
    (_updateLighting)
    (cc))

// INSTANTLY move a character:
(hollywooMethod moveCharacter [actorName :Dynamic newPosition :StageFacing newFacing :Continuation cc]
    (removeCharacter actorName
        (makeCC cc
            (addCharacter actorName newPosition newFacing cc))))

// INSTANTLY swap characters
(hollywooMethod swapCharacters [actorNameA actorNameB :Continuation cc]
    // remove both, then re-add both, so they don't trigger
    // cascading auto z adjustments on top of each other:
    (let [a (dictGet .characters (_currentScene) actorNameA)
            asp a.stagePosition
            asf a.stageFacing
            b (dictGet .characters (_currentScene) actorNameB)
            bsp b.stagePosition
            bsf b.stageFacing]
        (removeCharacter actorNameA
            (makeCC cc
                (removeCharacter actorNameB
                    (makeCC cc
                        (addCharacter actorNameA bsp bsf
                            (makeCC cc
                                (addCharacter actorNameB asp asf cc)))))))))

// Strobe and continue the script:
(hollywooMethod strobeCharacter [:Bool skipping :String actorName :Float sec :Int times :Continuation cc]
    (_strobe skipping false actorName sec times)
    (cc))

(hollywooMethod strobeProp [:Bool skipping :String propName :Float sec :Int times :Continuation cc]
    (_strobe skipping true propName sec times)
    (cc))

// Strobe and wait for it to finish:
(hollywooMethod awaitStrobeCharacter [:Bool skipping :String actorName :Float sec :Int times :Continuation cc]
    (_strobe skipping false actorName sec times cc))

(hollywooMethod awaitStrobeProp [:Bool skipping :String propName :Float sec :Int times :Continuation cc]
    (_strobe skipping true propName sec times cc))

(hollywooMethod addProp [name :Dynamic position :Continuation cc]
    (let [name (FuzzyMapTools.bestMatch props name)
            prop (dictGet props name)
            position (resolvePosition position (Prop name))]
        (.push .propOrder (_currentScene) name)
        (dictSet .props (_currentScene) name (objectWith position prop))
        (_updateLighting)
        (director.showProp prop position (appearanceFlag shownProps name) .camera (_currentScene) cc)))

(hollywooMethod removeProp [name :Continuation cc]
    (let [name (FuzzyMapTools.bestMatch props name)]
        (.remove .propOrder (_currentScene) name)
        (.remove .props (_currentScene) name)
        (_updateLighting)
        (director.hideProp (dictGet props name) .camera (_currentScene) cc)))

(hollywooMethod clearProps [:Continuation cc]
    (set .propOrder (_currentScene) [])
    (_ccForEach (collect (.keys .props (_currentScene)))
        ->[name cc] (removeProp name cc)
        cc))

// Dialogue:

(hollywooMethod intercut [:Map<String,String> actorNamesToSceneNames :Continuation cc]
    (set intercutMap (new FuzzyMap<String>))
    (doFor =>actor scene actorNamesToSceneNames
        (dictSet intercutMap actor scene))
    (cc))

(hollywooMethod endIntercut [:Continuation cc]
    (set intercutMap null)
    (cc))

(hollywooMethod timedTitleCard [:Bool skipping :Dynamic time :Array<String> lines :Continuation cc]
    (doFor line (filter lines)
        (dialogHistory.push (Super line)))
    (when skipping
        (cc)
        (return))
    (let [inputDelayKey (inputKey)
            cc ->{(stopWaitForInput inputDelayKey)(director.hideTitleCard)(cc)}]
        (director.showTitleCard lines
            (makeCC cc
                // Allow skipping
                (startWaitForInput cc inputDelayKey)
                (delay skipping time cc true)))))

(hollywooMethod showTitleCard [:Array<String> lines :Continuation cc]
    (doFor line (filter lines)
        (dialogHistory.push (Super line)))
    (director.showTitleCard lines cc)
    (cc))

(hollywooMethod hideTitleCard [:Continuation cc]
    (director.hideTitleCard)
    (cc))

(defMacro timedTitleCardV2 [time lines &opt label]
    `(commands
        SHOWTITLECARD ,lines
        ,(if label `(label ,label) `(cc))
        DELAY ,time
        HIDETITLECARD
        ))

(defReaderMacro "TIMEDTITLECARDV2" [stream]
    (let [nextLineStream
                (stream.expect "hollywoo macro line" ->(stream.takeLineAsStream))
            time (read nextLineStream)
            lines (read nextLineStream)]
        (nextLineStream.dropWhitespace)
        (if (nextLineStream.isEmpty)
                `(timedTitleCardV2 ,time ,lines)
            `(timedTitleCardV2 ,time ,lines ,(read nextLineStream)))))

// TODO themed titleCard (wait for song or sound)


(hollywooMethod superText [:Bool skipping text :Continuation cc]
    (dialogHistory.push (Super text))
    (if skipping
            (cc)
        (showDialog skipping "" Super "" text cc)))

(hollywooMethod timedSuperText [:Bool skipping text :Dynamic sec :Continuation cc]
    (when skipping
        (dialogHistory.push (Super text))
        (cc)
        (return))
    (let [cc ->:Void {(director._hideDialog) (cc)}]
        (superText skipping text cc)
        (delay skipping sec cc true)))

// TODO themed superText

(hollywooMethod normalSpeech [:Bool skipping actorName wryly text :Continuation cc]
    (processIntercut skipping actorName
        (makeCC cc
            (let [character (dictGet .characters (_currentScene) actorName)
                    actor character.actor]
                (director.showExpression actor wryly)
                (showDialog skipping actorName (OnScreen character) wryly text cc)))))

(hollywooMethod interruptedSpeech [:Bool skipping actorName wryly :String text :Continuation cc]
    (overridePlayMode Watch (makeCC null null))
    // naively guess that the interruption should happen X% of the way through the spoken
    // line, where X = the position of the last / in the text
    (let [wrappedCC (makeCC cc (restorePlayMode cc))
            slashIndex (text.lastIndexOf "/")]
        (when (= -1 slashIndex) (throw "interruptedSpeech requires a / in the text to indicate the cutoff point!"))
        (let [slashPercent (/ slashIndex text.length)
                // Remove the /
                text "$(text.substr 0 slashIndex)$(text.substr (+ 1 slashIndex))"
                // Remove possible double-space left by the /
                text (StringTools.replace text "  " " ")
                text (StringTools.replace text "  " " ")]
            (processIntercut skipping actorName
                (makeCC cc
                    (let [character (dictGet .characters (_currentScene) actorName)
                            actor character.actor]
                        (director.showExpression actor wryly)
                        (showDialog skipping actorName (OnScreen character) wryly text wrappedCC slashPercent)))))))

(hollywooMethod offScreenSpeech [:Bool skipping actorName wryly text :Continuation cc]
    (let [actor (dictGet actors actorName)]
        (director.showExpression actor wryly)
        (showDialog skipping actorName (OffScreen actor) wryly text cc)))

(hollywooMethod voiceOver [:Bool skipping actorName wryly text :Continuation cc]
    (showDialog skipping actorName (VoiceOver (dictGet actors actorName)) wryly text cc))

(hollywooMethod onPhoneSpeech [:Bool skipping actorName wryly text :Continuation cc]
    (processIntercut skipping actorName
        (makeCC cc
            (showDialog skipping actorName (ifLet [charOnScreen (try (dictGet .characters (_currentScene) actorName) (catch [e] null))]
                                            {
                                                (director.showExpression charOnScreen.actor wryly)
                                                (OnScreen charOnScreen)
                                            }
                                        (FromPhone (dictGet actors actorName))) wryly text cc))))

(hollywooMethod customSpeech [:Bool skipping type actorName wryly args text :Continuation cc]
    (processIntercut skipping actorName
        (makeCC cc
            (showDialog skipping actorName (Custom type (dictGet .characters (_currentScene) actorName) args) wryly text cc))))

(hollywooMethod timedCutToBlack [:Bool skipping :Dynamic seconds :Continuation cc]
    (when skipping
        (cc)
        (return))
    (director.showBlackScreen)
    (delay skipping seconds ->:Void {(director.hideBlackScreen)(cc)} true))

(hollywooMethod cutToBlack [:Continuation cc]
    (director.showBlackScreen)
    (cc))

(hollywooMethod endCutToBlack [:Continuation cc]
    (director.hideBlackScreen)
    (cc))

(hollywooMethod rollCredits [:Bool skipping :String creditsTSV :Continuation cc &opt :Float timeLimit]
    (when skipping
        (cc)
        (return))
    (director.rollCredits
        (let [creditsData
                    (for line (.split .content (Stream.fromString creditsTSV) "\n") (line.split "\t"))
                headings
                    []
                edgeCaseCredits
                    (new Map<String,String>)
                headingIndices
                    (new Map<String,Int>)
                headingData
                    (new Map<String,Array<Array<String>>>)]
            // Find headings
            (doFor [idx data] (enumerate creditsData)
                (case data
                    ((or [heading] [heading ""])
                        (headings.push heading)
                        (dictSet headingIndices heading idx)
                        (dictSet headingData heading []))
                    ((when (StringTools.endsWith heading ":") ["" heading])
                        (headings.push (substr heading 0 -1))
                        (dictSet headingIndices (substr heading 0 -1) idx)
                        (dictSet headingData (substr heading 0 -1) []))
                    (otherwise)))

            // Sort loadedCredits by headings and check for missing headings
            (doFor data loadedCredits
                (case data
                    ([heading credit _sourceOrUrl]
                        (ifLet [idx (dictGet headingIndices heading)]
                                (let [edgeCaseCredit (dictGet edgeCaseCredits heading)
                                        hd (dictGet headingData heading)
                                        // Push unless given a duplicate:
                                        hdPush ->:Void data
                                                    (let [dataStr (data.toString)]
                                                        (when (= credit edgeCaseCredit)
                                                            (return))
                                                        (doFor d hd
                                                            (when (= (d.toString) dataStr)
                                                                (return)))
                                                        (hd.push data))
                                        headingLineData (nth creditsData idx)]
                                    (case headingLineData
                                        ([heading ""]
                                            (dictSet edgeCaseCredits heading credit)
                                            (setNth headingLineData 1 credit))
                                        (["" heading]
                                            (hdPush ["" "   ${credit}"]))
                                        ((or [heading] [heading _])
                                            (hdPush ["" credit]))
                                        (never otherwise)))

                            (throw "no heading $heading to place credit $data")))
                    (otherwise
                        (throw "unsupported credit data $data"))))

            // Insert sorted credits under headings
            (doFor heading (reverse headings)
                (let [idx (dictGet headingIndices heading)
                        hd (dictGet headingData heading)]
                    (doFor data (reverse hd)
                        (creditsData.insert (+ idx 1) data))))

            // Return the formatting enum list
            (for data creditsData
                (case data
                    ([]
                        Break)
                    ([col1]
                        (OneColumn col1))
                    ([col1 col2]
                        (TwoColumn col1 col2))
                    ([col1 col2 col3]
                        (ThreeColumn col1 col2 col3))
                    (otherwise
                        (throw "unsupported credits line $data")))))

        cc
        timeLimit))

(hollywooMethod themedRollCredits [:Bool skipping :String creditsTSV :String songKey :Continuation cc &opt :Float volumeMod]
    (when skipping
        (cc)
        (return))
    (playSong skipping songKey (makeCC null null) volumeMod)
    (rollCredits
        skipping
        creditsTSV
        (makeCC cc
            (stopSong skipping cc))
        (director.getSongLength (dictGet songs songKey))))

// This redefinition allows you to call (hollywooMethod) in your hollywoo implementation dsls and movie scripts:
(defMacroVar avoidDuplicateDefinition false)