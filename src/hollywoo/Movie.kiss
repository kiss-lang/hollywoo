(defMacro makeCC [&body b]
    `->:Void [] (runWithErrorChecking ->:Void {,@b}))

(function dynamicArray [&rest :Array<Dynamic> elements]
    elements)

// This file is designed to be loaded again by subclasses, with macroVar "subclass" set
(#unless subclass

    // Settings
    (savedVar :Bool showCaptions false)
    (savedVar :PlayMode playMode NotSet)

    (var MAX_CAPTION_DURATION 3)
    (prop &mut :Int captionId 0)

    (prop :Array<HistoryElement<Actor>> dialogHistory [])
    (var MAX_DIALOG_HISTORY 50)

    (prop &mut :String currentSong "")
    (prop &mut :Float currentSongVolumeMod 0)
    (prop &mut :Bool currentSongLooping false)

    // Mostly immutable, reusable resources:
    (prop :FuzzyMap<Set> sets (new FuzzyMap<Set>))
    (prop :FuzzyMap<Actor> actors (new FuzzyMap<Actor>))
    (prop :FuzzyMap<Sound> sounds (new FuzzyMap<Sound>))
    (prop :FuzzyMap<String> soundDescriptions (new FuzzyMap<String>))
    (prop :FuzzyMap<Song> songs (new FuzzyMap<Song>))
    (prop :FuzzyMap<Prop> props (new FuzzyMap<Prop>))
    (prop :Map<String,VoiceTrack> voiceTracks (new Map))
    (prop :Map<String,CustomDialogTypeHandler<Actor>> _customDialogTypeHandlers (new Map))
    (prop :FuzzyMap<FuzzyMap<VoiceLine>> voiceLines (new FuzzyMap<FuzzyMap<VoiceLine>>))
    (prop :Map<String,Bool> dirtyActors (new Map))
    (prop :Map<String,Bool> dirtyProps (new Map))
    
    // Used to give unique, persistent IDs to voice tracks
    (prop :Map<String,Int> voiceTracksPerActor (new Map))

    (prop &mut :DelayHandling delayHandling AutoWithSkip)
    
    (prop &mut :String lastDelay "")
    (prop &mut :Float lastDelayLength 0)


    // Mutable representation of frames in time:
    (prop :FuzzyMap<Scene<Set,Actor,Prop,Camera>> scenes (new FuzzyMap<Scene<Set,Actor,Prop,Camera>>))

    (prop :Map<String,Bool> shownScenes (new Map))
    (prop :Map<String,Bool> shownProps (new Map))
    (prop :Map<String,Bool> shownCharacters (new Map))

    // This is set and unset by doPreload defined in HollywooDSL.kiss
    (prop &mut isLoading false)
    (prop &mut didLoading false)

    (prop &mut scavenged false)
    // Reuse as many loaded assets from the previously running Movie as safely possible
    (method scavengeObjects [:Movie<Set,Actor,Sound,Song,Prop,VoiceTrack,Camera,LightSource> movie]
        (set scavenged true)
        (let [&mut t 0
                &mut c 0]
            (doFor =>key actor movie.actors
                (+= t 1)
                (unless (movie.dirtyActors.exists key)
                    (+= c 1)
                    (dictSet actors key actor)
                    (movie.actors.remove key)))
            (doFor =>key prop movie.props
                (+= t 1)
                (unless (movie.dirtyProps.exists key)
                    (+= c 1)
                    (dictSet props key prop)
                    (movie.props.remove key)))
            (doFor =>key sound movie.sounds
                (+= t 1)
                (+= c 1)
                (dictSet soundDescriptions key (dictGet movie.soundDescriptions key))
                (dictSet sounds key sound)
                (movie.sounds.remove key))
            (doFor =>key song movie.songs
                (+= t 1)
                (+= c 1)
                (dictSet songs key song)
                (movie.songs.remove key))
            (doFor =>key voiceTrack movie.voiceTracks
                (+= t 1)
                (+= c 1)
                (dictSet voiceTracks key voiceTrack)
                (movie.voiceTracks.remove key))
            (doFor =>actor vl movie.voiceLines
                (dictSet voiceLines actor vl))
            (print "scavenge reused ${c}/${t} objects")))

    (function :Appearance appearanceFlag [:Map<String,Bool> map :String key]
        (if (dictGet map key)
                ReAppearance
            {
                (dictSet map key true)
                FirstAppearance
            }))

    (prop &mut :String sceneKey "")
    (method _currentScene [] (dictGet scenes sceneKey))

    (prop &mut :FuzzyMap<String> intercutMap)
    (prop &mut :Map<String,Int> altIdx (new Map))
    (method :Void processIntercut [:Bool skipping :String actorName :Continuation cc]
        (when intercutMap
            (whenLet [sceneForActor (try (dictGet intercutMap actorName) (catch [e] null))]
                (unless (= sceneForActor sceneKey)
                    (setScene skipping sceneForActor cc)
                    (return))))
        (cc))
    
    (prop :Map<String,Bool> _silentCustomDialogTypes (new Map))
    (savedVar :Bool playVoiceTracksForSilentDialog false)
    (method registerCustomDialogTypeHandler [:String key :CustomDialogTypeHandler<Actor> handler &opt :Bool isSilent]
        (_customDialogTypeHandlers.set key handler)
        (when ?isSilent (dictSet _silentCustomDialogTypes key true)))
    
    (prop &mut :Void->Void _hideCustomDialog null)
    (var DELAY_BETWEEN_VOICE_TRACKS 0.1)
    (method :Void showDialog [:Bool skipping actorName dialogType wryly text cc]
        // Hide custom dialog when the next dialog appears unless HIDECUSTOMDIALOG is called manually:
        (when _hideCustomDialog
            (_hideCustomDialog)
            (set _hideCustomDialog null))
        (dialogHistory.push (Dialog actorName dialogType wryly text))
        (when skipping
            (cc)
            (return))
        (processIntercut skipping actorName
            (makeCC
                (let [isSilentType
                            ?(whenLet [(Custom type _ _) dialogType]
                                (_silentCustomDialogTypes.exists type))
                        cc ->:Void
                            (delay skipping DELAY_BETWEEN_VOICE_TRACKS ->:Void {
                                (director.hideDialog) (cc)
                            })
                        &mut customCC cc
                        &mut skipCC cc]
                    // When an actorName is given, check for a voiced line to play.
                    // Otherwise, assume it is un-voiced super text
                    (when (and (or !isSilentType playVoiceTracksForSilentDialog) actorName (< 0 (count voiceTracks)))
                            (case
                                (let [voiceLineKey
                                            (if (voiceLineMatches.exists text)
                                                    .value (voiceLineMatches.get text)
                                                (FuzzyMapTools.bestMatch (dictGet voiceLines actorName) text false))]
                                    (if voiceLineKey
                                            {
                                                (#when debug
                                                    (voiceLineMatches.put text (new JsonableString voiceLineKey)))
                                                (dictGet (dictGet voiceLines actorName) voiceLineKey)
                                            }
                                        null))
                                ((objectWith trackKey start end alts)
                                    (case (dictGet altIdx "$actorName $text")
                                        (null
                                            (dictSet altIdx "$actorName $text" 0)
                                            (set customCC ->:Void {})
                                            (director.playVoiceTrack (dictGet voiceTracks trackKey) 1 start end cc))
                                        ((when (>= idx alts.length) idx)
                                            (dictSet altIdx "$actorName $text" 0)
                                            (set customCC ->:Void {})
                                            (director.playVoiceTrack (dictGet voiceTracks trackKey) 1 start end cc))
                                        (idx
                                            (let [alt (nth alts idx)
                                                    start alt.start
                                                    end alt.end]
                                                (+= (dictGet altIdx "$actorName $text") 1)
                                                (set customCC ->:Void {})
                                                (director.playVoiceTrack (dictGet voiceTracks trackKey) 1 start end cc))))
                                    
                                    (set skipCC ->:Void {(director.stopVoiceTrack (dictGet voiceTracks trackKey)) (cc)}))
                                ((objectWith trackKey start end)
                                    (director.playVoiceTrack (dictGet voiceTracks trackKey) 1 start end cc)
                                    (set skipCC ->:Void {(director.stopVoiceTrack (dictGet voiceTracks trackKey)) (cc)}))
                                (otherwise)))
                    (case dialogType
                        ((Custom type character args)
                            (ifLet [handler (dictGet _customDialogTypeHandlers type)]
                                    (let [cleanupFunc (handler actorName character wryly args text skipCC customCC)]
                                        (set _hideCustomDialog cleanupFunc))
                                (throw "No handler for custom dialog type $type")))
                        (otherwise (director.showDialog actorName dialogType wryly text skipCC)))))))

    (defMacro withIndexedPath [pathVar typeDefaultDir &body body]
        (#if (or sys hxnodejs)
                `(let [,pathVar
                            (if (StringTools.startsWith ,pathVar assetDir)
                                    ,pathVar
                                (assetPath ,typeDefaultDir ,pathVar))]
                    ,@body)
            body))

    (prop &mut loadedObjects 0)
    (prop &mut loadCalls 0)
    // Methods for loading new assets in a hollywoo movie follow a special naming convention.
    // _add*()  is a method which takes the asset DIRECTLY and adds it to the corresponding asset map.
    //          This is to be used in cases where the asset needs to be loaded specially in a way
    //          the Director's load*() function can't handle.
    // _load*() is a method which takes the asset's PATH and lets the Director load the asset object.
    //
    //          Neither of these is not meant to be called directly, as a precaution against loading new assets
    //          at Movie runtime. However, within the context of (preload...) blocks, they will be
    //          bound to these names:
    // add*()
    // new*()   At which point you can use them. Therefore, if you accidentally try to call new*()
    //          outside of a preload block, your code won't compile.
    //          Which is desired because (preload...) blocks are meant to be allowed at any point in a script,
    //          even following the usage of the assets they load. Runtime loading allows for errors
    //          caused by moving the load calls or asset usages around so the load doesn't precede the usage.
    (method _loadVoiceTrack [actorName :String path :String lineJson]
        (+= loadCalls 1)
        (let [actorNumVoiceTracks (or (dictGet voiceTracksPerActor actorName) 0)
                trackKey "${actorName}${actorNumVoiceTracks}"]
            (cond
                ((voiceTracks.exists trackKey)
                    (dictSet voiceTracksPerActor actorName (+ 1 actorNumVoiceTracks)))
                (true
                    (withIndexedPath path "vo"
                        (+= loadedObjects 1)
                        (_addVoiceTrack actorName (director.loadVoiceTrack path) lineJson))))))

    (method _addVoiceTrack [actorName :VoiceTrack track :String lineJson]
        (assert isLoading)
        (let [actorNumVoiceTracks (or (dictGet voiceTracksPerActor actorName) 0)
                trackKey "${actorName}${actorNumVoiceTracks}"
                :haxe.DynamicAccess<Dynamic> lines (Json.parse lineJson)]
            (dictSet voiceTracksPerActor actorName (+ 1 actorNumVoiceTracks))
            (dictSet voiceTracks trackKey track)
            (doFor =>key line (lines.keyValueIterator)
                (let [:Array<VoiceLine> alts
                            (if line.alts
                                    (for alt (the Array<Dynamic> line.alts) (objectWith [start alt.start end alt.end] trackKey))
                                [])]
                    (unless (voiceLines.existsExactly actorName)
                        (dictSet voiceLines actorName (new FuzzyMap<VoiceLine>)))
                    (dictSet (dictGet voiceLines actorName) key (objectWith [start line.start end line.end] trackKey alts))))))

    (method _noVoiceTracks [actorName]
        (assert isLoading)
        (dictSet voiceTracksPerActor actorName 0)
        (dictSet voiceLines actorName (new FuzzyMap<VoiceLine>)))

    (method _loadProp [name :String path]
        (+= loadCalls 1)
        (unless (props.existsExactly name)
            (withIndexedPath path "images"
                (+= loadedObjects 1)
                (_addProp name (director.loadProp path)))))

    (method _addProp [name :Prop prop]
        (assert isLoading)
        (dictSet props name prop))

    (method _loadSong [name :String path]
        (+= loadCalls 1)
        (unless (songs.existsExactly name)
            (withIndexedPath path "music"
                (+= loadedObjects 1)
                (_addSong name (director.loadSong path)))))

    (method _addSong [name :Song song]
        (assert isLoading)
        (dictSet songs name song))

    (method _loadActor [name :String path]
        (+= loadCalls 1)
        (unless (actors.existsExactly name)
            (withIndexedPath path "images"
                (+= loadedObjects 1)
                (_addActor name (director.loadActor path)))))

    (method _addActor [name :Actor actor]
        (assert isLoading)
        (dictSet actors name actor))

    (method _loadSet [name :String path]
        (+= loadCalls 1)
        (unless (sets.existsExactly name)
            (withIndexedPath path "images"
                (+= loadedObjects 1)
                (_addSet name (director.loadSet path)))))

    (method _addSet [name :Set set]
        (assert isLoading)
        (dictSet sets name set))

    (method _newSceneFromSet [name :String setKey :SceneTime time :ScenePerspective perspective :Camera camera]
        (assert isLoading)
        (dictSet scenes name (objectWith
                                    [
                                        set
                                            (director.cloneSet (dictGet sets setKey))
                                        characters
                                            (new FuzzyMap<Character<Actor>>)
                                        propOrder
                                            []
                                        props
                                            (new FuzzyMap<StageProp<Prop>>)
                                        camera
                                            camera
                                    ]
                                    time
                                    perspective)))

    (method _loadSound [name :String path :String description]
        (+= loadCalls 1)
        (unless (sounds.existsExactly name)
            (withIndexedPath path "sounds"
                (+= loadedObjects 1)
                (_addSound name (director.loadSound path) description))))

    (method _addSound [name :Sound s :String description]
        (assert isLoading)
        (dictSet sounds name s)
        (dictSet soundDescriptions name description))

    (method _ccForEach <>[T] [:Iterable<T> collection :(T,Continuation)->Void do_ :Continuation finalCC]
        (let [:Iterator<T> iter (collection.iterator)]
            (withFunctions
                [
                    (:Void doNext []
                        (if (iter.hasNext)
                                (do_ (iter.next) doNext)
                            (finalCC)))
                ]
                (doNext))))

    (method _hideCurrentScene [:Continuation cc]
        (if sceneKey
                // hide current scene background
                (let [currentScene (dictGet scenes sceneKey)]
                    (director.hideLighting)
                    (director.hideSet currentScene.set currentScene.camera
                        (makeCC
                            // hide current scene characters 
                            (_ccForEach 
                                currentScene.characters
                                ->[:Character<Actor> c :Continuation cc]
                                    (director.hideCharacter c currentScene.camera cc)
                                (makeCC
                                    // hide current scene props, etc.
                                    (_ccForEach
                                        currentScene.props
                                        ->[:StageProp<Prop> p :Continuation cc]
                                            (director.hideProp p.prop currentScene.camera cc)
                                        cc))))))
            (cc)))
    
    (method _showScene [:Scene<Set,Actor,Prop,Camera> scene :Appearance appearance :Camera camera :Continuation cc]
        (director.showLighting scene.time .elements (lightSources.get (FuzzyMapTools.bestMatch scenes sceneKey)) camera)
        // Show current scene background
        (director.showSet scene.set scene.time scene.perspective appearance camera
            (makeCC
                // Show current scene characters 
                (_ccForEach 
                    (object iterator ->(scene.characters.keys))
                    ->[:String key :Continuation cc]
                        (director.showCharacter (dictGet scene.characters key) (appearanceFlag shownCharacters key) camera cc)
                    (makeCC
                        // show current scene props, etc.
                        (_ccForEach
                            scene.propOrder
                            ->[:String propKey :Continuation cc]
                                (let [p (dictGet scene.props propKey)]
                                    (director.showProp p.prop p.position ReAppearance .camera (_currentScene) cc))
                            cc))))))

    (prop &mut :Bool paused false)
    (prop &mut :Continuation onComplete null)

    (method pause []
        (unless paused
            (TimerWithPause.pause)
            (set paused true)
            (director.pause)))

    (method resume []
        (when paused
            (set paused false)
            (director.resume)
            (TimerWithPause.resume)))

    (prop &mut promptedRecording false)
    (method promptToRecord [:Continuation cc]
        (unless kiss_tools.OBSTools.obsIsRecording
            (director.chooseString
                "Start recording?"
                ["Yes" "No"]
                ->:Void choice 
                    (case choice 
                        ("Yes"
                            (set promptedRecording true)
                            (director.prepareForRecording)
                            (kiss_tools.OBSTools.startObs)
                            (cc))
                        (otherwise (cc))))))

    (method stopPromptedRecording []
        (set promptedRecording (and promptedRecording kiss_tools.OBSTools.obsIsRecording))
        (when promptedRecording
            (kiss_tools.OBSTools.stopObs)
            (set promptedRecording false)))


    (prop :Map<String,Array<String>> positionsInScene (new Map))
    (method resolvePosition [:Dynamic position]
        (typeCase [position]
            ([:String positionKey]
                (let [positionsInThisScene (dictGet positionsInScene sceneKey)]
                    (unless (positionsInThisScene.contains positionKey)
                        (positionsInThisScene.push positionKey)))
                (stagePositions.get positionKey))
            ([:StagePosition position]
                position)
            (otherwise (throw "Not a position or position key: $position"))))

    (prop &mut :Map<String,Continuation> loopingSoundPlays (new Map))

    (#when (or sys hxnodejs)
        (prop :FuzzyMap<FuzzyMap<String>> assetPaths (new FuzzyMap))
        (prop &mut :String assetDir "")
        (prop :Array<Array<String>> loadedCredits [])
        (method _indexAssetPaths [:String assetDir]
            (set this.assetDir assetDir)
            (let [dirParts (assetDir.split "/")]
                (doFor part dirParts
                    (dictSet assetPaths part (new FuzzyMap))))
            (walkDirectory "" assetDir
                ->file (ifLet [[:: ...dirs basename] (file.split "/")
                                    ext (Path.extension file)
                                    noExt (Path.withoutExtension file)
                                    overrideEndings [
                                        "Edited"
                                        "-edited"
                                    ]
                                    overrideExtensions [
                                        "$ext"
                                        "png" // It's common to edit a jpg into a png
                                        "wav" // or an ogg into a wav
                                        "ogg" // or an mp3 into an ogg
                                    ]
                                    overridePath file]
                                {
                                    (cond 
                                        ((= ext "tsv")
                                            // If an asset's source is neither pixabay or unsplash (public domain),
                                            // make some noise if you forgot to include its license in a file:
                                            (let [content (sys.io.File.getContent file)
                                                    source (.shift (content.split "\t"))]
                                                (case source
                                                    ("pixabay.com" null)
                                                    ("unsplash.com" null)
                                                    ("openclipart.org" null)
                                                    ("pixnio.com" null)
                                                    (otherwise
                                                        (#when debug
                                                            (unless (sys.FileSystem.exists "${noExt}.LICENSE.txt")
                                                                (print "Warning! License file may be required for redistributing $file from $source")))))))
                                        (true
                                            (doFor [ending extension] (intersect overrideEndings overrideExtensions)
                                                (let [possibleOverride "${noExt}${ending}.${extension}"]
                                                    (when (sys.FileSystem.exists possibleOverride)
                                                        (#when debug
                                                            (print "$file overridden by $possibleOverride"))
                                                        (set overridePath possibleOverride)
                                                        (break))))))
                                    (doFor dir dirs
                                        (dictSet (dictGet assetPaths dir) basename overridePath))
                                }
                            (print "Warning: asset $file cannot be indexed"))
                ->folderToFilter (assertLet [[:: ... dir] (folderToFilter.split "/")]
                                    (unless (assetPaths.existsExactly dir)
                                        (dictSet assetPaths dir (new FuzzyMap)))
                                    false)))

        (method assetPath [directory filename]
            (let [dirMap (dictGet assetPaths directory)
                    basename (FuzzyMapTools.bestMatch dirMap filename)
                    noExt (Path.withoutExtension basename)
                    tsv "${noExt}.tsv"]
                (if (dirMap.existsExactly tsv)
                        (let [tsvContent (sys.io.File.getContent (dictGet dirMap tsv))]
                            (loadedCredits.push (tsvContent.split "\t")))
                    (#when debug (print "Warning: no credit tsv file for ${directory}/${filename}")))
                (dictGet dirMap basename))))

    (function choosePlayMode [:Director<Dynamic,Dynamic,Dynamic,Dynamic,Dynamic,Dynamic,Dynamic,Dynamic> director :Void->Void cc]
        (director.chooseString
            "Choose a Play Mode\n\nThe Play Mode setting determines how the story will flow forward.\n\nRead mode lets you go at your own pace, stopping after most dialogue until you choose to continue.\n\nWatch mode proceeds automatically like a cutscene or a movie.\n\nYou can still skip dialogue or speed up animations in either mode.\n\nYou can change your decision any time in the Options menu.\n\n"
            ["Read Mode" "Watch Mode"]
            ->:Void mode {
                (case mode
                    ("Read Mode"
                        (set Movie.playMode Read))
                    ("Watch Mode"
                        (set Movie.playMode Watch))
                    (never otherwise))
                ~Movie.playMode

                (when director.movie
                    (set director.movie.delayHandling
                        (case hollywoo.Movie.playMode
                            (Read Manual)
                            (Watch AutoWithSkip)
                            (never otherwise))))

                (cc)
            }))

    (defNew
        [
            // "View" in the Model-View-Controller architecture:
            &prop :Director<Set,Actor,Sound,Song,Prop,VoiceTrack,Camera,LightSource> director
            :String lightSourceJsonFile
            :LightSource defaultLightSource
            :String stagePositionsJson
            :String delayLengthsJson
            :String voiceLineMatchesJson
            :String miscFloatJson
            :String miscIntJson
        ]
        [
            :JsonMap<StagePosition> stagePositions
                (new JsonMap stagePositionsJson (new StagePosition 0 0 0))
            :JsonMap<JsonableArray<LightSource>> lightSources
                (new JsonMap lightSourceJsonFile (new JsonableArray [] defaultLightSource))
            :JsonMap<HFloat> delayLengths
                (new JsonMap delayLengthsJson (new HFloat 0.5))
            :JsonStringMap voiceLineMatches
                (new JsonMap voiceLineMatchesJson (new JsonableString ""))
            :JsonMap<HFloat> miscFloats
                (new JsonMap miscFloatJson (new HFloat 0))
            :JsonMap<HInt> miscInts
                (new JsonMap miscIntJson (new HInt 0))
            :Map<String,String> sceneMusic (new Map)
            :Map<String,Float> sceneMusicVolume (new Map)
            &mut :String playingSceneMusic null
        ]
        (super)
        (set director.movie this)
        (set onSkipEnd
            ->:Void {
                (doFor play loopingSoundPlays
                    (play))
                (when currentSong
                    (playSong false currentSong ->:Void {} currentSongVolumeMod currentSongLooping false))
            })

        (let [shortcutHandler (director.shortcutHandler)
                cc ->(resume)]
            (set shortcutHandler.onSelectItem
                ->process {
                    (pause)
                    // TODO this is dicey but it allows processes to use the handler:
                    (shortcutHandler.start)
                    (process cc)
                })
            (set shortcutHandler.onBadKey
                ->[_ _]
                    (when shortcutHandler.currentMap
                        (shortcutHandler.start)))
            (shortcutHandler.registerItem "{escape} Pause the movie"
                ->cc (director.showPauseMenu cc))
            (shortcutHandler.registerItem "{tab} show dialog history"
                ->cc {
                    (director.showDialogHistory
                        (if (> dialogHistory.length MAX_DIALOG_HISTORY)
                                (dialogHistory.slice (- dialogHistory.length MAX_DIALOG_HISTORY))
                            dialogHistory) cc)
                })
            
            (#when debug
                (shortcutHandler.registerItem "[d]efine [d]elay"
                    ->cc
                        (director.enterString "Redefine $lastDelay from $lastDelayLength sec?" 
                            ->lengthStr
                                (let [length (Std.parseFloat lengthStr)]
                                    (delayLengths.put lastDelay (new HFloat length))
                                    (cc))))

                (shortcutHandler.registerItem "[d]efine [m]isc [i]nt"
                    ->cc
                        (director.chooseString "Which misc int?" (collect (miscInts.keys)) 
                            ->key
                                (director.enterString "Redefine $key from ${.value (miscInts.get key)}?" 
                                    ->valStr
                                        (let [v (Std.parseInt valStr)]
                                            (miscInts.put key (new HInt v))
                                            (cc)))))

                (shortcutHandler.registerItem "[d]efine [m]isc [f]loat"
                    ->cc
                        (director.chooseString "Which misc float?" (collect (miscFloats.keys)) 
                            ->key
                                (director.enterString "Redefine $key from ${.value (miscFloats.get key)}?" 
                                    ->valStr
                                        (let [v (Std.parseFloat valStr)]
                                            (miscFloats.put key (new HFloat v))
                                            (cc)))))

                (shortcutHandler.registerItem "[d]efine [p]osition"
                    ->cc
                        (director.chooseString "Which position?" (dictGet positionsInScene sceneKey)
                            ->positionKey
                                (director.defineStagePosition
                                    .camera (_currentScene)
                                    ->[:StagePosition position] {
                                        (stagePositions.put positionKey position)
                                        (cc)
                                    }
                                    (stagePositions.get positionKey))))
                (shortcutHandler.registerItem "[d]efine [l]ight source"
                    ->cc
                        (director.defineLightSource
                            ->[:LightSource source] {
                                (let [arr (lightSources.get sceneKey)]
                                    (arr.elements.push source)
                                    (lightSources.put sceneKey arr)
                                    (director.hideLighting)
                                    (director.showLighting .time (_currentScene) arr.elements .camera (_currentScene))
                                    (cc))
                            }))
                (shortcutHandler.registerItem "[r]emove [l]ight source"
                    ->cc
                        (let [arr (lightSources.get sceneKey)
                                stringArr (for ls arr (ls.stringify))
                                stringMap (for [key ls] (zipThrow stringArr arr) =>key ls)]
                            (director.chooseString "Remove which light source?" stringArr
                                ->choice
                                    (let [ls (dictGet stringMap choice)]
                                        (arr.elements.remove ls)
                                        (lightSources.put sceneKey arr)
                                        (director.hideLighting)
                                        (director.showLighting .time (_currentScene) arr.elements .camera (_currentScene))
                                        (cc)))))

                // TODO
                **(shortcutHandler.registerItem "[n]ext label"
                    ->cc
                        (skipToNextLabel))

                // TODO
                **(shortcutHandler.registerItem "skip to [l]abel"
                    ->cc
                        (let [runners (labelRunners)]
                            (director.chooseString
                                "Skip to scene?"
                                (sort (collect (runners.keys)))
                                ->label {
                                            (resume)
                                            ((dictGet runners label))
                                        }))))))
        
    @:keep
    (method :Void _strobe [:Bool skipping :Bool prop :String actorOrPropKey :Float strobeSec :Int times &opt :Continuation cc]
        (when skipping
            (when cc
                (cc))
            (return))

        (let [&mut :Dynamic propOrCharacter
                    // dictGet on a fuzzymap will function as an assertion that the prop or character is already added,
                    // but a try-catch here could make that more clear
                    (if prop
                            (dictGet .props (_currentScene) actorOrPropKey)
                        (dictGet .characters (_currentScene) actorOrPropKey))
                appearance ReAppearance
                camera .camera (_currentScene)
                &mut shown true
                :Function show
                    (if prop
                            (let [_prop propOrCharacter.prop
                                    _position propOrCharacter.position]
                                (set propOrCharacter _prop)
                                (director.showProp.bind _ _position))
                        director.showCharacter)
                :Function hide
                    (if prop
                            director.hideProp
                        director.hideCharacter)]
            (TimerWithPause.interval
                ->:Void
                    (if shown
                            {
                                (hide propOrCharacter camera ->:Void {})
                                (set shown false)
                            }
                        {
                            (show propOrCharacter appearance camera ->:Void {})
                            (set shown true)
                        })
                strobeSec
                (* times 2))
            (when cc
                (TimerWithPause.delay cc (* strobeSec 2 (+ 1 times))))))

    (method :Void handleCaption [:Bool skipping :String name]
        (when showCaptions
            (whenLet [desc (dictGet soundDescriptions name)
                        id captionId++
                        sound (dictGet sounds name)]
                (director.showCaption desc id)
                (delay skipping (min MAX_CAPTION_DURATION (director.getSoundLength sound))
                    (makeCC
                        (director.hideCaption id))))))
    
    (method :Int miscInt [:String key &opt :Int defaultVal]
        (if (miscInts.exists key)
                .value (miscInts.get key)
            {
                (when defaultVal
                    (miscInts.put key (new HInt defaultVal)))
                defaultVal
            }))
    
    (method :Float miscFloat [:String key &opt :Float defaultVal]
        (if (miscFloats.exists key)
                .value (miscFloats.get key)
            {
                (when defaultVal
                    (miscFloats.put key (new HFloat defaultVal)))
                defaultVal
            }))

    (method :Float resolveDelay [:Dynamic lengthOrKey]
        (typeCase [lengthOrKey]
            ([:Float sec] sec)
            ([:String key]
                (let [lengthFloat .value (delayLengths.get key)]
                    (set lastDelay key)
                    (set lastDelayLength lengthFloat)
                    lengthFloat))
            (never otherwise))))

// END Parent class definitions

(defMacro indexAssetPaths [dir]
    `(preload
        (_indexAssetPaths ,dir)))

(defMacro mode [mode &body body]
    `(case Movie.playMode
        (,mode ,@body)
        (otherwise (cc))))

// Some real magic happens here. This macro defines a method, AND a reader macro
// for calling it with skipping and cc passed automatically if cc is an argument.
// GOTCHA: DO NOT use (method) directly in this file!!
(defMacro hollywooMethod [nameAndType argList &builder b &body body]
    (let [args (expList argList)
            numArgs args.length
            methodName (symbolNameValue nameAndType true)
            &mut readerMacroStart "$(.toUpperCase methodName) "
            argSymbolNames (for arg args (symbolNameValue arg true true))]
        (when (apply and (for name argSymbolNames !(= -1 (.indexOf ["cc" "skipping"] name)))) (set readerMacroStart (StringTools.trim readerMacroStart)))
        `{
            (defReaderMacro ,readerMacroStart [stream &builder b]
                (let [nextLineStream
                            (stream.expect "hollywoo macro line" ->(stream.takeLineAsStream))
                        methodCall
                            (b.callSymbol
                                ,methodName
                                ,(for arg args
                                    (cond
                                        ((= "cc" (symbolNameValue arg true true))
                                            (b.callSymbol "b.symbol" [(b.str "cc")]))
                                        ((= "skipping" (symbolNameValue arg true true))
                                            (b.callSymbol "b.symbol" [(b.str "skipping")]))
                                        (true (b.callSymbol "try" [
                                                (b.callSymbol "read" [(b.symbol "nextLineStream")])
                                                // optional arguments may not be present:
                                                (b.callSymbol "catch" [(b.list [(b.symbol "e")]) (b.callSymbol "b.symbol" [(b.str "null")])])
                                            ])))))]
                    methodCall))
            (#unless subclass @:keep (method ,nameAndType ,argList ,@body))
        }))

(hollywooMethod :Void restorePlayMode [:Continuation cc]
    (set delayHandling
        (case hollywoo.Movie.playMode
            (Read Manual)
            (Watch AutoWithSkip)
            (never otherwise)))
    (cc))

(hollywooMethod :Void overridePlayMode [:PlayMode mode :Continuation cc]
    (set delayHandling
        (case mode
            (Read Manual)
            (Watch AutoWithSkip)
            (never otherwise)))
    (cc))

(hollywooMethod :Void hideCustomDialog [:Continuation cc]
    (when _hideCustomDialog
        (_hideCustomDialog)
        (set _hideCustomDialog null))
    (cc))

(hollywooMethod :Void delay [:Bool skipping :Dynamic length :Continuation cc]
    (when skipping
        (cc)
        (return))
    (let [sec (resolveDelay length)]
        (case delayHandling
            (Auto
                (TimerWithPause.delay cc sec))
            (AutoWithSkip
                (let [autoDelay
                            (TimerWithPause.delay
                                ->{
                                    (director.stopWaitForInput cc)
                                    (cc)
                                }
                                sec)]
                    (director.startWaitForInput 
                        ->{
                            (director.stopWaitForInput cc)
                            (TimerWithPause.stop autoDelay)
                            (cc)
                        })))
            (Manual
                (director.showInputIcon)
                (director.startWaitForInput
                    ->{
                        (director.hideInputIcon)
                        (director.stopWaitForInput cc)
                        (cc)
                    }))
            (otherwise (throw "Unsupported delay type $delayHandling")))))

(hollywooMethod :Void watchModeDelay [:Bool skipping :Dynamic length :Continuation cc]
    (mode Watch (delay skipping length cc)))

(hollywooMethod setSceneSong [:String scene :String songKey &opt :Float volumeMod :Continuation cc]
    (dictSet sceneMusic scene songKey)
    (dictSet sceneMusicVolume scene volumeMod)
    (when cc (cc)))

(hollywooMethod setCurrentSceneSong [:Bool skipping :String songKey :Continuation cc &opt :Float volumeMod]
    (dictSet sceneMusic sceneKey songKey)
    (dictSet sceneMusicVolume sceneKey volumeMod)
    (cond 
        ((= playingSceneMusic songKey)
            (changeSongVolume skipping volumeMod cc))
        (true
            (set playingSceneMusic songKey)
            (stopSong skipping (makeCC null))
            (loopSong skipping songKey (makeCC null) volumeMod)
            (cc))))

(hollywooMethod setScene [:Bool skipping :String name :Continuation cc]
    (hideCustomDialog
        (makeCC
            (_hideCurrentScene
                (makeCC
                    (let [name (FuzzyMapTools.bestMatch scenes name)]
                        (set sceneKey name)
                        (ifLet [songKey (dictGet sceneMusic name)]
                                    // Keep the song going if it's the same as current. Otherwise, take over!
                                    (unless (= playingSceneMusic songKey)
                                        (set playingSceneMusic songKey)
                                        (stopSong skipping (makeCC null))
                                        (loopSong skipping songKey (makeCC null) (dictGet sceneMusicVolume name)))
                            (when playingSceneMusic
                                (set playingSceneMusic null)
                                (stopSong skipping (makeCC null))))
                        (unless (positionsInScene.exists sceneKey)
                            (dictSet positionsInScene sceneKey []))
                        (_showScene
                            (dictGet scenes name)
                            (appearanceFlag shownScenes name)
                            .camera (dictGet scenes name)
                            cc)))))))

(hollywooMethod playSound [:Bool skipping :String name :Continuation cc &opt :Float volumeMod :Bool waitForEnd :Bool dontWaitForInput]
    (set volumeMod (or volumeMod 1))
    (assert (<= 0 volumeMod 1))
    (let [name (FuzzyMapTools.bestMatch sounds name)]
        (localVar looping ?(dictGet loopingSoundPlays name))
        (whenLet [desc (dictGet soundDescriptions name)]
            (dialogHistory.push (Sound desc)))
        (when skipping
            (cc)
            (return))
        (unless looping
            (handleCaption skipping name))
        (let [sound (dictGet sounds name)]
            (withFunctions
                [
                    (:Void innerCC []
                        (unless looping
                            (director.stopSound sound)
                            (unless dontWaitForInput
                                (director.stopWaitForInput innerCC)))
                        (cc))
                ]
                (unless (or looping dontWaitForInput)
                    (when waitForEnd
                        (director.startWaitForInput innerCC)))
                (director.playSound sound volumeMod (when waitForEnd innerCC))))
        (unless waitForEnd
            (cc))))

(hollywooMethod awaitPlaySound [:Bool skipping :String name :Continuation cc &opt :Float volumeMod]
    (playSound skipping name cc volumeMod true))

(hollywooMethod awaitPlaySounds [:Bool skipping :Array<String> names :Continuation cc &opt :Float volumeMod]
    (let [names (names.copy)]
        (localVar &mut currentSound "")
        (localVar endCC
            (makeCC
                (whileLet [soundKey (names.shift)]
                    // This just adds the sounds to the history:
                    (playSound true soundKey (makeCC null) volumeMod false true))
                (when currentSound
                    (stopSound skipping currentSound cc))
                (cc)))
        (when skipping
            (endCC)
            (return))
        (director.startWaitForInput endCC)
        (_ccForEach names
            ->[name cc]
                {
                    (set currentSound name)
                    (playSound skipping name cc volumeMod true true)
                }
            endCC)))

(hollywooMethod stopSound [:Bool skipping :String name :Continuation cc]
    (let [name (FuzzyMapTools.bestMatch sounds name)]
        (loopingSoundPlays.remove name)
        (unless skipping
            (director.stopSound (dictGet sounds name))))
    (cc))

(hollywooMethod loopSound [:Bool skipping :String name :Continuation cc &opt :Float volumeMod]
    // Even when skipping, create a lambda that plays an iteration of the sound,
    // so if skipping ends and the sound is still supposed to be looping,
    // we can start it!
    (let [name (FuzzyMapTools.bestMatch sounds name)]
        (withFunctions
            [
                (:Void playAgain []
                    (playSound false name
                        (makeCC
                            (when (loopingSoundPlays.exists name)
                                (playAgain)))
                        volumeMod
                        true))
            ]
            (handleCaption skipping name)
            (dictSet loopingSoundPlays name playAgain)
            (unless skipping
                (playAgain))))
    (cc))

(hollywooMethod playSong [:Bool skipping :String name :Continuation cc &opt :Float volumeMod :Bool loop :Bool waitForEnd]
    (set volumeMod (or volumeMod 1))
    (assert (<= 0 volumeMod 1))
    (set currentSong (FuzzyMapTools.bestMatch songs name))
    (set currentSongVolumeMod volumeMod)
    (set currentSongLooping ?loop)
    (when skipping
        (cc)
        (return))
    (director.playSong (dictGet songs currentSong) volumeMod ?loop ?waitForEnd cc))

(hollywooMethod changeSongVolume [:Bool skipping :Float volumeMod :Continuation cc]
    (set currentSongVolumeMod volumeMod)
    (when skipping
        (cc)
        (return))
    (director.changeSongVolume volumeMod cc))

(hollywooMethod awaitPlaySong [:Bool skipping :String name :Continuation cc &opt :Float volumeMod]
    (when skipping
        (cc)
        (return))
    (playSong skipping name cc volumeMod false true))
    
(hollywooMethod loopSong [:Bool skipping :String name :Continuation cc &opt :Float volumeMod]
    (playSong skipping name cc volumeMod true false))

(hollywooMethod stopSong [:Bool skipping cc]
    (set currentSong "")
    (unless skipping
        (director.stopSong))
    (cc))

(hollywooMethod autoZProcess [:StagePosition position :Continuation cc]
    // handle auto z recursively
    (ifLet [(Some (objectWith zPerLayer frontLayer)) (director.autoZConfig)]
            {
                (doFor =>name otherCharacter .characters (_currentScene)
                    (when (and (= position.x otherCharacter.stagePosition.x) (= position.y otherCharacter.stagePosition.y) (= position.z otherCharacter.stagePosition.z))
                        (moveCharacter name (new StagePosition position.x position.y (+ otherCharacter.stagePosition.z zPerLayer)) otherCharacter.stageFacing cc)
                        (return)))
                (cc)
            }
        (cc)))

(hollywooMethod addCharacter [actorName :Dynamic position :StageFacing facing :Continuation cc]
    (let [actorName (FuzzyMapTools.bestMatch actors actorName)
            position (resolvePosition position)
            character (object stagePosition position stageFacing facing actor (dictGet actors actorName))]
        (autoZProcess position
            (makeCC
                (dictSet .characters (_currentScene) actorName character)
                (director.showCharacter
                    character
                    (appearanceFlag shownCharacters actorName)
                    .camera (_currentScene)
                    cc))))) 

(hollywooMethod removeCharacter [actorName :Continuation cc]
    (let [c (dictGet .characters (_currentScene) actorName)]
        (.remove .characters (_currentScene) actorName)
        (director.hideCharacter c .camera (_currentScene) cc)))

(hollywooMethod clearCharacters [:Continuation cc]
    (doFor =>name c .characters (_currentScene)
        (director.hideCharacter c .camera (_currentScene) (makeCC null))
        (.remove .characters (_currentScene) name))
    (cc))

// INSTANTLY move a character:
(hollywooMethod moveCharacter [actorName :Dynamic newPosition :StageFacing newFacing :Continuation cc]
    (removeCharacter actorName
        (makeCC
            (addCharacter actorName newPosition newFacing cc))))

// INSTANTLY swap characters
(hollywooMethod swapCharacters [actorNameA actorNameB :Continuation cc]
    // remove both, then re-add both, so they don't trigger 
    // cascading auto z adjustments on top of each other:
    (let [a (dictGet .characters (_currentScene) actorNameA)
            asp a.stagePosition
            asf a.stageFacing
            b (dictGet .characters (_currentScene) actorNameB)
            bsp b.stagePosition
            bsf b.stageFacing]
        (removeCharacter actorNameA
            (makeCC
                (removeCharacter actorNameB
                    (makeCC
                        (addCharacter actorNameA bsp bsf
                            (makeCC
                                (addCharacter actorNameB asp asf cc)))))))))

// Strobe and continue the script:
(hollywooMethod strobeCharacter [:Bool skipping :String actorName :Float sec :Int times :Continuation cc]
    (_strobe skipping false actorName sec times)
    (cc))

(hollywooMethod strobeProp [:Bool skipping :String propName :Float sec :Int times :Continuation cc]
    (_strobe skipping true propName sec times)
    (cc))

// Strobe and wait for it to finish:
(hollywooMethod awaitStrobeCharacter [:Bool skipping :String actorName :Float sec :Int times :Continuation cc]
    (_strobe skipping false actorName sec times cc))

(hollywooMethod awaitStrobeProp [:Bool skipping :String propName :Float sec :Int times :Continuation cc]
    (_strobe skipping true propName sec times cc))

// TODO moveCharacter remove them, add them to another scene
// TODO moveCharacterAndFollow remove them, add them to another scene, set that the scene

(hollywooMethod addProp [name :Dynamic position :Continuation cc]
    (let [name (FuzzyMapTools.bestMatch props name)
            prop (dictGet props name)
            position (resolvePosition position)]
        (.push .propOrder (_currentScene) name)
        (dictSet .props (_currentScene) name (objectWith position prop))
        (director.showProp prop position (appearanceFlag shownProps name) .camera (_currentScene) cc)))

(hollywooMethod removeProp [name :Continuation cc]
    (let [name (FuzzyMapTools.bestMatch props name)]
        (.remove .propOrder (_currentScene) name)
        (.remove .props (_currentScene) name)
        (director.hideProp (dictGet props name) .camera (_currentScene) cc)))

(hollywooMethod clearProps [:Continuation cc]
    (set .propOrder (_currentScene) [])
    (_ccForEach (collect (.keys .props (_currentScene)))
        ->[name cc] (removeProp name cc)
        cc))

// Dialogue:

(hollywooMethod intercut [:Map<String,String> actorNamesToSceneNames :Continuation cc]
    (set intercutMap (new FuzzyMap<String>))
    (doFor =>actor scene actorNamesToSceneNames
        (dictSet intercutMap actor scene))
    (cc))

(hollywooMethod endIntercut [:Continuation cc]
    (set intercutMap null)
    (cc))

(hollywooMethod timedTitleCard [:Bool skipping :Dynamic time :Array<String> lines :Continuation cc]
    (when skipping
        (cc)
        (return))
    (let [cc ->{(director.hideTitleCard)(cc)}]
        (director.showTitleCard lines
            (makeCC
                // Allow skipping
                (director.startWaitForInput cc)
                (delay skipping time cc)))))

// TODO themed titleCard (wait for song or sound)


(hollywooMethod superText [:Bool skipping text :Continuation cc]
    (dialogHistory.push (Super text))
    (if skipping
            (cc)
        // Skip voice track handling:
        // TODO don't skip it when playing silent dialog
        (director.showDialog "" Super "" text cc)))

(hollywooMethod timedSuperText [:Bool skipping text :Dynamic sec :Continuation cc]
    (when skipping
        (dialogHistory.push (Super text))
        (cc)
        (return))
    (let [cc ->:Void {(director.hideDialog) (cc)}]
        (superText skipping text cc)
        (delay skipping sec cc)))

// TODO themed superText

(hollywooMethod normalSpeech [:Bool skipping actorName wryly text :Continuation cc]
    (processIntercut skipping actorName
        (makeCC
            (let [character (dictGet .characters (_currentScene) actorName)
                    actor character.actor]
                (director.showExpression actor wryly)
                (showDialog skipping actorName (OnScreen character) wryly text cc)))))

(hollywooMethod offScreenSpeech [:Bool skipping actorName wryly text :Continuation cc]
    (let [actor (dictGet actors actorName)]
        (director.showExpression actor wryly)
        (showDialog skipping actorName (OffScreen actor) wryly text cc)))

(hollywooMethod voiceOver [:Bool skipping actorName wryly text :Continuation cc]
    (showDialog skipping actorName (VoiceOver (dictGet actors actorName)) wryly text cc))

(hollywooMethod onPhoneSpeech [:Bool skipping actorName wryly text :Continuation cc]
    (processIntercut skipping actorName
        (makeCC
            (showDialog skipping actorName (ifLet [charOnScreen (try (dictGet .characters (_currentScene) actorName) (catch [e] null))]
                                            {
                                                (director.showExpression charOnScreen.actor wryly)
                                                (OnScreen charOnScreen)
                                            }
                                        (FromPhone (dictGet actors actorName))) wryly text cc))))

(hollywooMethod customSpeech [:Bool skipping type actorName wryly args text :Continuation cc]
    (processIntercut skipping actorName
        (makeCC
            (showDialog skipping actorName (Custom type (dictGet .characters (_currentScene) actorName) args) wryly text cc))))

(hollywooMethod timedCutToBlack [:Bool skipping :Dynamic seconds :Continuation cc]
    (when skipping
        (cc)
        (return))
    (director.showBlackScreen)
    (delay skipping seconds ->:Void {(director.hideBlackScreen)(cc)}))

(hollywooMethod cutToBlack [:Continuation cc]
    (director.showBlackScreen)
    (cc))

(hollywooMethod endCutToBlack [:Continuation cc]
    (director.hideBlackScreen)
    (cc))

(hollywooMethod rollCredits [:Bool skipping :String creditsTSV :Continuation cc &opt :Float timeLimit]
    (when skipping
        (cc)
        (return))
    (director.rollCredits
        (let [creditsData
                    (for line (.split .content (Stream.fromString creditsTSV) "\n") (line.split "\t"))
                headings
                    []    
                edgeCaseCredits
                    (new Map<String,String>)
                headingIndices
                    (new Map<String,Int>)
                headingData
                    (new Map<String,Array<Array<String>>>)]
            // Find headings
            (doFor [idx data] (enumerate creditsData)
                (case data
                    ((or [heading] [heading ""])
                        (headings.push heading)
                        (dictSet headingIndices heading idx)
                        (dictSet headingData heading []))
                    ((when (StringTools.endsWith heading ":") ["" heading])
                        (headings.push (substr heading 0 -1))
                        (dictSet headingIndices (substr heading 0 -1) idx)
                        (dictSet headingData (substr heading 0 -1) []))
                    (otherwise)))
            
            // Sort loadedCredits by headings and check for missing headings
            (doFor data loadedCredits
                (case data
                    ([heading credit _sourceOrUrl]
                        (ifLet [idx (dictGet headingIndices heading)]
                                (let [edgeCaseCredit (dictGet edgeCaseCredits heading)
                                        hd (dictGet headingData heading)
                                        // Push unless given a duplicate:
                                        hdPush ->:Void data
                                                    (let [dataStr (data.toString)]
                                                        (when (= credit edgeCaseCredit)
                                                            (return))
                                                        (doFor d hd
                                                            (when (= (d.toString) dataStr)
                                                                (return)))
                                                        (hd.push data))
                                        headingLineData (nth creditsData idx)]
                                    (case headingLineData
                                        ([heading ""]
                                            (dictSet edgeCaseCredits heading credit)
                                            (setNth headingLineData 1 credit))
                                        (["" heading]
                                            (hdPush ["" "   ${credit}"]))
                                        ((or [heading] [heading _])
                                            (hdPush ["" credit]))
                                        (never otherwise)))
                                
                            (throw "no heading $heading to place credit $data")))
                    (otherwise
                        (throw "unsupported credit data $data"))))

            // Insert sorted credits under headings
            (doFor heading (reverse headings)
                (let [idx (dictGet headingIndices heading)
                        hd (dictGet headingData heading)]
                    (doFor data (reverse hd)
                        (creditsData.insert (+ idx 1) data))))

            // Return the formatting enum list
            (for data creditsData
                (case data
                    ([]
                        Break)
                    ([col1]
                        (OneColumn col1))
                    ([col1 col2]
                        (TwoColumn col1 col2))
                    ([col1 col2 col3]
                        (ThreeColumn col1 col2 col3))
                    (otherwise
                        (throw "unsupported credits line $data")))))
        
        cc
        timeLimit))

(hollywooMethod themedRollCredits [:Bool skipping :String creditsTSV :String songKey :Continuation cc &opt :Float volumeMod]
    (when skipping
        (cc)
        (return))
    (playSong skipping songKey (makeCC null) volumeMod)
    (rollCredits
        skipping 
        creditsTSV
        (makeCC
            (stopSong skipping cc))
        (director.getSongLength (dictGet songs songKey))))