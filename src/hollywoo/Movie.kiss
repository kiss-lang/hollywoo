(defMacro makeCC [&body b]
    `->:Void {,@b})

(function dynamicArray [&rest :Array<Dynamic> elements]
    elements)

// This file is designed to be loaded again by subclasses, with macroVar "subclass" set
(#unless subclass
    // Settings
    (savedVar :Bool showCaptions false)
    (savedVar :PlayMode playMode NotSet)

    (var MAX_CAPTION_DURATION 3)
    (prop &mut :Int captionId 0)

    (prop :Array<HistoryElement<Actor>> dialogHistory [])

    // Mostly immutable, reusable resources:
    (prop :FuzzyMap<Set> sets (new FuzzyMap<Set>))
    (prop :FuzzyMap<Actor> actors (new FuzzyMap<Actor>))
    (prop :FuzzyMap<Sound> sounds (new FuzzyMap<Sound>))
    (prop :FuzzyMap<String> soundDescriptions (new FuzzyMap<String>))
    (prop :FuzzyMap<Song> songs (new FuzzyMap<Song>))
    (prop :FuzzyMap<Prop> props (new FuzzyMap<Prop>))
    (prop :Map<String,VoiceTrack> voiceTracks (new Map))
    (prop :Map<String,CustomDialogTypeHandler<Actor>> _customDialogTypeHandlers (new Map))
    (prop :FuzzyMap<FuzzyMap<VoiceLine>> voiceLines (new FuzzyMap<FuzzyMap<VoiceLine>>))
    
    // Used to give unique, persistent IDs to voice tracks
    (prop :Map<String,Int> voiceTracksPerActor (new Map))

    (prop &mut :DelayHandling delayHandling AutoWithSkip)
    
    (prop &mut :String lastDelay "")
    (prop &mut :Float lastDelayLength 0)


    // Mutable representation of frames in time:
    (prop :FuzzyMap<Scene<Set,Actor,Prop,Camera>> scenes (new FuzzyMap<Scene<Set,Actor,Prop,Camera>>))

    (prop :Map<String,Bool> shownScenes (new Map))
    (prop :Map<String,Bool> shownProps (new Map))
    (prop :Map<String,Bool> shownCharacters (new Map))

    // This is set and unset by doPreload defined in HollywooDSL.kiss
    (prop &mut isLoading false)

    (function :Appearance appearanceFlag [:Map<String,Bool> map :String key]
        (if (dictGet map key)
                ReAppearance
            {
                (dictSet map key true)
                FirstAppearance
            }))

    (prop &mut :String sceneKey "")
    (method _currentScene [] (dictGet scenes sceneKey))

    (prop &mut :FuzzyMap<String> intercutMap)
    (prop &mut :Map<String,Int> altIdx (new Map))
    (method :Void processIntercut [actorName :Continuation cc]
        (when intercutMap
            (whenLet [sceneForActor (try (dictGet intercutMap actorName) (catch [e] null))]
                (unless (= sceneForActor sceneKey)
                    (setScene sceneForActor cc)
                    (return))))
        (cc))
    
    (prop :Map<String,Bool> _silentCustomDialogTypes (new Map))
    (savedVar :Bool playVoiceTracksForSilentDialog false)
    (method registerCustomDialogTypeHandler [:String key :CustomDialogTypeHandler<Actor> handler &opt :Bool isSilent]
        (_customDialogTypeHandlers.set key handler)
        (when ?isSilent (dictSet _silentCustomDialogTypes key true)))
    
    (prop &mut :Void->Void _hideCustomDialog null)
    (var DELAY_BETWEEN_VOICE_TRACKS 0.1)
    (method :Void showDialog [:Bool skipping actorName dialogType wryly text cc]
        // Hide custom dialog when the next dialog appears unless HIDECUSTOMDIALOG is called manually:
        (when _hideCustomDialog
            (_hideCustomDialog)
            (set _hideCustomDialog null))
        (dialogHistory.push (Dialog actorName dialogType wryly text))
        (when skipping
            (cc)
            (return))
        (processIntercut actorName
            (makeCC
                (let [isSilentType
                            ?(whenLet [(Custom type _ _) dialogType]
                                (_silentCustomDialogTypes.exists type))
                        cc ->:Void
                            (delay skipping DELAY_BETWEEN_VOICE_TRACKS ->:Void {
                                (director.hideDialog) (cc)
                            })
                        &mut customCC cc
                        &mut skipCC cc]
                    // When an actorName is given, check for a voiced line to play.
                    // Otherwise, assume it is un-voiced super text
                    (when (and (or !isSilentType playVoiceTracksForSilentDialog) actorName (< 0 (count voiceTracks)))
                            (case
                                (let [voiceLineKey
                                            (if (voiceLineMatches.exists text)
                                                    .value (voiceLineMatches.get text)
                                                (FuzzyMapTools.bestMatch (dictGet voiceLines actorName) text false))]
                                    (if voiceLineKey
                                            {
                                                (#when debug
                                                    (voiceLineMatches.put text (new JsonableString voiceLineKey)))
                                                (dictGet (dictGet voiceLines actorName) voiceLineKey)
                                            }
                                        null))
                                ((objectWith trackKey start end alts)
                                    (case (dictGet altIdx "$actorName $text")
                                        (null
                                            (dictSet altIdx "$actorName $text" 0)
                                            (set customCC ->:Void {})
                                            (director.playVoiceTrack (dictGet voiceTracks trackKey) 1 start end cc))
                                        ((when (>= idx alts.length) idx)
                                            (dictSet altIdx "$actorName $text" 0)
                                            (set customCC ->:Void {})
                                            (director.playVoiceTrack (dictGet voiceTracks trackKey) 1 start end cc))
                                        (idx
                                            (let [alt (nth alts idx)
                                                    start alt.start
                                                    end alt.end]
                                                (+= (dictGet altIdx "$actorName $text") 1)
                                                (set customCC ->:Void {})
                                                (director.playVoiceTrack (dictGet voiceTracks trackKey) 1 start end cc))))
                                    
                                    (set skipCC ->:Void {(director.stopVoiceTrack (dictGet voiceTracks trackKey)) (cc)}))
                                ((objectWith trackKey start end)
                                    (director.playVoiceTrack (dictGet voiceTracks trackKey) 1 start end cc)
                                    (set skipCC ->:Void {(director.stopVoiceTrack (dictGet voiceTracks trackKey)) (cc)}))
                                (otherwise)))
                    (case dialogType
                        ((Custom type character args)
                            (ifLet [handler (dictGet _customDialogTypeHandlers type)]
                                    (let [cleanupFunc (handler actorName character wryly args text skipCC customCC)]
                                        (set _hideCustomDialog cleanupFunc))
                                (throw "No handler for custom dialog type $type")))
                        (otherwise (director.showDialog actorName dialogType wryly text skipCC)))))))

    (method noVoiceTracks [actorName]
        (dictSet voiceTracksPerActor actorName 0)
        (dictSet voiceLines actorName (new FuzzyMap<VoiceLine>)))

    (method newVoiceTrack [actorName :VoiceTrack track :String lineJson]
        (let [actorNumVoiceTracks (or (dictGet voiceTracksPerActor actorName) 0)
                trackKey "${actorName}${actorNumVoiceTracks}"
                :haxe.DynamicAccess<Dynamic> lines (Json.parse lineJson)]
            (dictSet voiceTracksPerActor actorName (+ 1 actorNumVoiceTracks))
            (dictSet voiceTracks trackKey track)
            (doFor =>key line (lines.keyValueIterator)
                (let [:Array<VoiceLine> alts
                            (if line.alts
                                    (for alt (the Array<Dynamic> line.alts) (objectWith [start alt.start end alt.end] trackKey))
                                [])]
                    (unless (voiceLines.existsExactly actorName)
                        (dictSet voiceLines actorName (new FuzzyMap<VoiceLine>)))
                    (dictSet (dictGet voiceLines actorName) key (objectWith [start line.start end line.end] trackKey alts))))))

    (method _ccForEach <>[T] [:Iterable<T> collection :(T,Continuation)->Void do_ :Continuation finalCC]
        (let [:Iterator<T> iter (collection.iterator)]
            (withFunctions
                [
                    (:Void doNext []
                        (if (iter.hasNext)
                                (do_ (iter.next) doNext)
                            (finalCC)))
                ]
                (doNext))))

    (method _hideCurrentScene [:Continuation cc]
        (if sceneKey
                // hide current scene background
                (let [currentScene (dictGet scenes sceneKey)]
                    (director.hideLighting)
                    (director.hideSet currentScene.set currentScene.camera
                        (makeCC
                            // hide current scene characters 
                            (_ccForEach 
                                currentScene.characters
                                ->[:Character<Actor> c :Continuation cc]
                                    (director.hideCharacter c currentScene.camera cc)
                                (makeCC
                                    // hide current scene props, etc.
                                    (_ccForEach
                                        currentScene.props
                                        ->[:StageProp<Prop> p :Continuation cc]
                                            (director.hideProp p.prop currentScene.camera cc)
                                        cc))))))
            (cc)))
    
    (method _showScene [:Scene<Set,Actor,Prop,Camera> scene :Appearance appearance :Camera camera :Continuation cc]
        (director.showLighting scene.time .elements (lightSources.get (FuzzyMapTools.bestMatch scenes sceneKey)) camera)
        // Show current scene background
        (director.showSet scene.set scene.time scene.perspective appearance camera
            (makeCC
                // Show current scene characters 
                (_ccForEach 
                    (object iterator ->(scene.characters.keys))
                    ->[:String key :Continuation cc]
                        (director.showCharacter (dictGet scene.characters key) (appearanceFlag shownCharacters key) camera cc)
                    (makeCC
                        // show current scene props, etc.
                        (_ccForEach
                            scene.props
                            ->[:StageProp<Prop> p :Continuation cc]
                                (director.showProp p.prop p.position ReAppearance .camera (_currentScene) cc)
                            cc))))))

    (prop &mut :Bool paused false)
    (prop &mut :Continuation onComplete null)

    (method pause []
        (unless paused
            (TimerWithPause.pause)
            (set paused true)
            (director.pause)))

    (method resume []
        (when paused
            (set paused false)
            (director.resume)
            (TimerWithPause.resume)))

    (prop &mut promptedRecording false)
    (method promptToRecord [:Continuation cc]
        (unless kiss_tools.OBSTools.obsIsRecording
            (director.chooseString
                "Start recording?"
                ["Yes" "No"]
                ->:Void choice 
                    (case choice 
                        ("Yes"
                            (set promptedRecording true)
                            (kiss_tools.OBSTools.startObs)
                            (cc))
                        (otherwise (cc))))))

    (method stopPromptedRecording []
        (set promptedRecording (and promptedRecording kiss_tools.OBSTools.obsIsRecording))
        (when promptedRecording
            (kiss_tools.OBSTools.stopObs)
            (set promptedRecording false)))


    (prop :Map<String,Array<String>> positionsInScene (new Map))
    (method resolvePosition [:Dynamic position]
        (typeCase [position]
            ([:String positionKey]
                (let [positionsInThisScene (dictGet positionsInScene sceneKey)]
                    (unless (positionsInThisScene.contains positionKey)
                        (positionsInThisScene.push positionKey)))
                (stagePositions.get positionKey))
            ([:StagePosition position]
                position)
            (otherwise (throw "Not a position or position key: $position"))))

    (#when (or sys hxnodejs)
        (prop :FuzzyMap<FuzzyMap<String>> assetPaths (new FuzzyMap))
        (prop :Array<Array<String>> loadedCredits [])
        (method _indexAssetPaths [:String assetDir]
            (let [dirParts (assetDir.split "/")]
                (doFor part dirParts
                    (dictSet assetPaths part (new FuzzyMap))))
            (walkDirectory "" assetDir
                ->file (ifLet [[:: ...dirs basename] (file.split "/")
                                    ext (Path.extension file)
                                    noExt (Path.withoutExtension file)
                                    overrideEndings [
                                        "Edited"
                                        "-edited"
                                    ]
                                    overrideExtensions [
                                        "$ext"
                                        "png" // It's common to edit a jpg into a png
                                        "wav" // or an ogg into a wav
                                        "ogg" // or an mp3 into an ogg
                                    ]
                                    overridePath file]
                                {
                                    (unless (= ext "tsv")
                                        (doFor [ending extension] (intersect overrideEndings overrideExtensions)
                                            (let [possibleOverride "${noExt}${ending}.${extension}"]
                                                (when (sys.FileSystem.exists possibleOverride)
                                                    (#when debug
                                                        (print "$file overridden by $possibleOverride"))
                                                    (set overridePath possibleOverride)
                                                    (break)))))
                                    (doFor dir dirs
                                        (dictSet (dictGet assetPaths dir) basename overridePath))
                                }
                            (print "Warning: asset $file cannot be indexed"))
                ->folderToFilter (assertLet [[:: ... dir] (folderToFilter.split "/")]
                                    (unless (assetPaths.existsExactly dir)
                                        (dictSet assetPaths dir (new FuzzyMap)))
                                    false)))

        (method assetPath [directory filename]
            (let [dirMap (dictGet assetPaths directory)
                    basename (FuzzyMapTools.bestMatch dirMap filename)
                    noExt (Path.withoutExtension basename)
                    tsv "${noExt}.tsv"]
                (if (dirMap.existsExactly tsv)
                        (let [tsvContent (sys.io.File.getContent (dictGet dirMap tsv))]
                            (loadedCredits.push (tsvContent.split "\t")))
                    (print "Warning: no credit tsv file for ${directory}/${filename}"))
                (dictGet dirMap basename))))

    (function choosePlayMode [:Director<Dynamic,Dynamic,Dynamic,Dynamic,Dynamic,Dynamic,Dynamic,Dynamic> director :Void->Void cc]
        (director.chooseString
            "Choose a Play Mode\n\nThe Play Mode setting determines how the story will flow forward.\n\nRead mode lets you go at your own pace, stopping after most dialogue until you choose to continue.\n\nWatch mode proceeds automatically like a cutscene or a movie.\n\nYou can still skip dialogue or speed up animations in either mode.\n\nYou can change your decision any time in the Options menu.\n\n"
            ["Read Mode" "Watch Mode"]
            ->:Void mode {
                (case mode
                    ("Read Mode"
                        (set Movie.playMode Read))
                    ("Watch Mode"
                        (set Movie.playMode Watch))
                    (never otherwise))
                ~Movie.playMode

                (when director.movie
                    (set director.movie.delayHandling
                        (case hollywoo.Movie.playMode
                            (Read Manual)
                            (Watch AutoWithSkip)
                            (never otherwise))))

                (cc)
            }))

    (defNew
        [
            // "View" in the Model-View-Controller architecture:
            &prop :Director<Set,Actor,Sound,Song,Prop,VoiceTrack,Camera,LightSource> director
            :String lightSourceJsonFile
            :LightSource defaultLightSource
            :String stagePositionsJson
            :String delayLengthsJson
            :String voiceLineMatchesJson
        ]
        [
            :JsonMap<StagePosition> stagePositions
                (new JsonMap stagePositionsJson (new StagePosition 0 0 0))
            :JsonMap<JsonableArray<LightSource>> lightSources
                (new JsonMap lightSourceJsonFile (new JsonableArray [] defaultLightSource))
            :JsonMap<HFloat> delayLengths
                (new JsonMap delayLengthsJson (new HFloat 0.5))
            :JsonStringMap voiceLineMatches
                (new JsonMap voiceLineMatchesJson (new JsonableString ""))
        ]

        (set director.movie this)

        (let [shortcutHandler (director.shortcutHandler)
                cc ->(resume)]
            (set shortcutHandler.onSelectItem
                ->process {
                    (pause)
                    // TODO this is dicey but it allows processes to use the handler:
                    (shortcutHandler.start)
                    (process cc)
                })
            (set shortcutHandler.onBadKey
                ->[_ _]
                    (when shortcutHandler.currentMap
                        (shortcutHandler.start)))
            (shortcutHandler.registerItem "{escape} Pause the movie"
                ->cc (director.showPauseMenu cc))
            (shortcutHandler.registerItem "{tab} show dialog history"
                ->cc (director.showDialogHistory dialogHistory cc))
            
            (#when debug
                (shortcutHandler.registerItem "[d]efine [d]elay"
                    ->cc
                        (director.enterString "Redefine $lastDelay from $lastDelayLength sec?" 
                            ->lengthStr
                                (let [length (Std.parseFloat lengthStr)]
                                    (delayLengths.put lastDelay (new HFloat length))
                                    (cc))))
                (shortcutHandler.registerItem "[d]efine [p]osition"
                    ->cc
                        (director.chooseString "Which position?" (dictGet positionsInScene sceneKey)
                            ->positionKey
                                (director.defineStagePosition
                                    .camera (_currentScene)
                                    ->[:StagePosition position] {
                                        (stagePositions.put positionKey position)
                                        (cc)
                                    }
                                    (stagePositions.get positionKey))))
                (shortcutHandler.registerItem "[d]efine [l]ight source"
                    ->cc
                        (director.defineLightSource
                            ->[:LightSource source] {
                                (let [arr (lightSources.get sceneKey)]
                                    (arr.elements.push source)
                                    (lightSources.put sceneKey arr)
                                    (director.hideLighting)
                                    (director.showLighting .time (_currentScene) arr.elements .camera (_currentScene))
                                    (cc))
                            }))
                (shortcutHandler.registerItem "[r]emove [l]ight source"
                    ->cc
                        (let [arr (lightSources.get sceneKey)
                                stringArr (for ls arr (ls.stringify))
                                stringMap (for [key ls] (zipThrow stringArr arr) =>key ls)]
                            (director.chooseString "Remove which light source?" stringArr
                                ->choice
                                    (let [ls (dictGet stringMap choice)]
                                        (arr.elements.remove ls)
                                        (lightSources.put sceneKey arr)
                                        (director.hideLighting)
                                        (director.showLighting .time (_currentScene) arr.elements .camera (_currentScene))
                                        (cc)))))

                // TODO
                **(shortcutHandler.registerItem "[n]ext label"
                    ->cc
                        (skipToNextLabel))

                // TODO
                **(shortcutHandler.registerItem "skip to [l]abel"
                    ->cc
                        (let [runners (labelRunners)]
                            (director.chooseString
                                "Skip to scene?"
                                (sort (collect (runners.keys)))
                                ->label {
                                            (resume)
                                            ((dictGet runners label))
                                        })))))

        (super)))

// END Parent class definitions

(defMacro indexAssetPaths [dir]
    `(preload
        (_indexAssetPaths ,dir)))

(#unless subclass
    @:keep
    (method :Void _strobe [:Bool skipping :Bool prop :String actorOrPropKey :Float strobeSec :Int times &opt :Continuation cc]
        (when skipping
            (when cc
                (cc))
            (return))

        (let [&mut :Dynamic propOrCharacter
                    // dictGet on a fuzzymap will function as an assertion that the prop or character is already added,
                    // but a try-catch here could make that more clear
                    (if prop
                            (dictGet .props (_currentScene) actorOrPropKey)
                        (dictGet .characters (_currentScene) actorOrPropKey))
                appearance ReAppearance
                camera .camera (_currentScene)
                &mut shown true
                :Function show
                    (if prop
                            (let [_prop propOrCharacter.prop
                                    _position propOrCharacter.position]
                                (set propOrCharacter _prop)
                                (director.showProp.bind _ _position))
                        director.showCharacter)
                :Function hide
                    (if prop
                            director.hideProp
                        director.hideCharacter)]
            (TimerWithPause.interval
                ->:Void
                    (if shown
                            {
                                (hide propOrCharacter camera ->:Void {})
                                (set shown false)
                            }
                        {
                            (show propOrCharacter appearance camera ->:Void {})
                            (set shown true)
                        })
                strobeSec
                (* times 2))
            (when cc
                (TimerWithPause.delay cc (* strobeSec 2 (+ 1 times)))))))

// Some real magic happens here. This macro defines a method, AND a reader macro
// for calling it with skipping and cc passed automatically if cc is an argument.
// GOTCHA: DO NOT use (method) directly in this file!!
(defMacro hollywooMethod [nameAndType argList &builder b &body body]
    (let [args (expList argList)
            numArgs args.length
            methodName (symbolNameValue nameAndType true)
            &mut readerMacroStart "$(.toUpperCase methodName) "
            argSymbolNames (for arg args (symbolNameValue arg true true))]
        (when (apply and (for name argSymbolNames !(= -1 (.indexOf ["cc" "skipping"] name)))) (set readerMacroStart (StringTools.trim readerMacroStart)))
        `{
            (defReaderMacro ,readerMacroStart [stream &builder b]
                (let [nextLineStream
                            (stream.expect "hollywoo macro line" ->(stream.takeLineAsStream))
                        methodCall
                            (b.callSymbol
                                ,methodName
                                ,(for arg args
                                    (cond
                                        ((= "cc" (symbolNameValue arg true true))
                                            (b.callSymbol "b.symbol" [(b.str "cc")]))
                                        ((= "skipping" (symbolNameValue arg true true))
                                            (b.callSymbol "b.symbol" [(b.str "skipping")]))
                                        (true (b.callSymbol "try" [
                                                (b.callSymbol "read" [(b.symbol "nextLineStream")])
                                                // optional arguments may not be present:
                                                (b.callSymbol "catch" [(b.list [(b.symbol "e")]) (b.callSymbol "b.symbol" [(b.str "null")])])
                                            ])))))]
                    methodCall))
            (#unless subclass @:keep (method ,nameAndType ,argList ,@body))
        }))

(hollywooMethod :Void hideCustomDialog [:Continuation cc]
    (when _hideCustomDialog
        (_hideCustomDialog)
        (set _hideCustomDialog null))
    (cc))

(hollywooMethod :Void delay [:Bool skipping :Dynamic length :Continuation cc]
    (when skipping
        (cc)
        (return))
    (let [sec (typeCase [length]
                    ([:Float sec] sec)
                    ([:String key]
                        (let [lengthFloat .value (delayLengths.get key)]
                            (set lastDelay key)
                            (set lastDelayLength lengthFloat)
                            lengthFloat))
                    (never otherwise))]
        (case delayHandling
            (Auto
                (TimerWithPause.delay cc sec))
            (AutoWithSkip
                (let [autoDelay
                            (TimerWithPause.delay
                                ->{
                                    (director.stopWaitForInput cc)
                                    (cc)
                                }
                                sec)]
                    (director.startWaitForInput 
                        ->{
                            (director.stopWaitForInput cc)
                            (TimerWithPause.stop autoDelay)
                            (cc)
                        })))
            (Manual
                (director.showInputIcon)
                (director.startWaitForInput
                    ->{
                        (director.hideInputIcon)
                        (director.stopWaitForInput cc)
                        (cc)
                    }))
            (otherwise (throw "Unsupported delay type $delayHandling")))))

(hollywooMethod newSet [name :Set set]
    (assert isLoading)
    (dictSet sets name set))

(hollywooMethod newSceneFromSet [name :String setKey :SceneTime time :ScenePerspective perspective :Camera camera]
    (assert isLoading)
    (dictSet scenes name (objectWith
                                [
                                    set
                                        (.clone (dictGet sets setKey))
                                    characters
                                        (new FuzzyMap<Character<Actor>>)
                                    props
                                        (new FuzzyMap<StageProp<Prop>>)
                                    camera
                                        camera
                                ]
                                time
                                perspective)))

(hollywooMethod setScene [name :Continuation cc]
    (_hideCurrentScene
        (makeCC
            (let [name (FuzzyMapTools.bestMatch scenes name)]
                (set sceneKey name)
                (unless (positionsInScene.exists sceneKey)
                    (dictSet positionsInScene sceneKey []))
                (_showScene
                    (dictGet scenes name)
                    (appearanceFlag shownScenes name)
                    .camera (dictGet scenes name)
                    cc)))))
    

(hollywooMethod newSound [name :Sound s :String description]
    (assert isLoading)
    (dictSet sounds name s)
    (dictSet soundDescriptions name description))

(hollywooMethod playSound [:Bool skipping name :Continuation cc &opt :Float volumeMod :Bool waitForEnd]
    (when skipping
        (cc)
        (return))
    (set volumeMod (or volumeMod 1))
    (assert (<= 0 volumeMod 1))
    (localVar &mut :Null<Int> id null)
    (whenLet [desc (dictGet soundDescriptions name)]
        (dialogHistory.push (Sound desc)))
    (when showCaptions
        (whenLet [desc (dictGet soundDescriptions name)]
            (set id captionId++)
            (director.showCaption desc id)))
    (let [sound (dictGet sounds name)]
        (when (and showCaptions id)
            (delay skipping (min MAX_CAPTION_DURATION (director.getSoundLength sound))
                (makeCC
                    (director.hideCaption id))))
        (director.playSound sound volumeMod ?waitForEnd cc)))

(hollywooMethod awaitPlaySound [:Bool skipping name :Continuation cc &opt :Float volumeMod]
    (playSound skipping name cc volumeMod true))

(hollywooMethod stopSound [:Bool skipping name :Continuation cc]
    (unless skipping
        (director.stopSound (dictGet sounds name)))
    (cc))

(hollywooMethod newSong [name :Song song]
    (assert isLoading)
    (dictSet songs name song))

(hollywooMethod playSong [:Bool skipping name :Continuation cc &opt :Float volumeMod :Bool loop :Bool waitForEnd]
    // This actually SHOULDN'T skip because the music might be expected to continue on to the place
    // we skip to:
    **(when skipping
        (cc)
        (return))
    (set volumeMod (or volumeMod 1))
    (assert (<= 0 volumeMod 1))
    (director.playSong (dictGet songs name) volumeMod ?loop ?waitForEnd cc))

(hollywooMethod awaitPlaySong [:Bool skipping name :Continuation cc &opt :Float volumeMod]
    (when skipping
        (cc)
        (return))
    (playSong skipping name cc volumeMod false true))
    
(hollywooMethod loopSong [:Bool skipping name :Continuation cc &opt :Float volumeMod]
    (playSong skipping name cc volumeMod true false))

(hollywooMethod stopSong [:Bool skipping cc]
    (director.stopSong)
    (cc))

(hollywooMethod newActor [name :Actor actor]
    (assert isLoading)
    (dictSet actors name actor))

(hollywooMethod autoZProcess [:StagePosition position :Continuation cc]
    // handle auto z recursively
    (ifLet [(Some (objectWith zPerLayer frontLayer)) (director.autoZConfig)]
            {
                (doFor =>name otherCharacter .characters (_currentScene)
                    (when (and (= position.x otherCharacter.stagePosition.x) (= position.y otherCharacter.stagePosition.y) (= position.z otherCharacter.stagePosition.z))
                        (moveCharacter name (new StagePosition position.x position.y (+ otherCharacter.stagePosition.z zPerLayer)) otherCharacter.stageFacing cc)
                        (return)))
                (cc)
            }
        (cc)))

(hollywooMethod addCharacter [actorName :Dynamic position :StageFacing facing :Continuation cc]
    (let [actorName (FuzzyMapTools.bestMatch actors actorName)
            position (resolvePosition position)
            character (object stagePosition position stageFacing facing actor (dictGet actors actorName))]
        (autoZProcess position
            (makeCC
                (dictSet .characters (_currentScene) actorName character)
                (director.showCharacter
                    character
                    (appearanceFlag shownCharacters actorName)
                    .camera (_currentScene)
                    cc))))) 

(hollywooMethod removeCharacter [actorName :Continuation cc]
    (let [c (dictGet .characters (_currentScene) actorName)]
        (.remove .characters (_currentScene) actorName)
        (director.hideCharacter c .camera (_currentScene) cc)))

(hollywooMethod clearCharacters [:Continuation cc]
    (doFor =>name c .characters (_currentScene)
        (director.hideCharacter c .camera (_currentScene) (makeCC null))
        (.remove .characters (_currentScene) name))
    (cc))

// INSTANTLY move a character:
(hollywooMethod moveCharacter [actorName :Dynamic newPosition :StageFacing newFacing :Continuation cc]
    (removeCharacter actorName
        (makeCC
            (addCharacter actorName newPosition newFacing cc))))

// INSTANTLY swap characters
(hollywooMethod swapCharacters [actorNameA actorNameB :Continuation cc]
    // remove both, then re-add both, so they don't trigger 
    // cascading auto z adjustments on top of each other:
    (let [a (dictGet .characters (_currentScene) actorNameA)
            asp a.stagePosition
            asf a.stageFacing
            b (dictGet .characters (_currentScene) actorNameB)
            bsp b.stagePosition
            bsf b.stageFacing]
        (removeCharacter actorNameA
            (makeCC
                (removeCharacter actorNameB
                    (makeCC
                        (addCharacter actorNameA bsp bsf
                            (makeCC
                                (addCharacter actorNameB asp asf cc)))))))))

// Strobe and continue the script:
(hollywooMethod strobeCharacter [:Bool skipping :String actorName :Float sec :Int times :Continuation cc]
    (_strobe skipping false actorName sec times)
    (cc))

(hollywooMethod strobeProp [:Bool skipping :String propName :Float sec :Int times :Continuation cc]
    (_strobe skipping true propName sec times)
    (cc))

// Strobe and wait for it to finish:
(hollywooMethod awaitStrobeCharacter [:Bool skipping :String actorName :Float sec :Int times :Continuation cc]
    (_strobe skipping false actorName sec times cc))

(hollywooMethod awaitStrobeProp [:Bool skipping :String propName :Float sec :Int times :Continuation cc]
    (_strobe skipping true propName sec times cc))

// TODO moveCharacter remove them, add them to another scene
// TODO moveCharacterAndFollow remove them, add them to another scene, set that the scene

(hollywooMethod newProp [name :Prop prop]
    (assert isLoading)
    (dictSet props name prop))

(hollywooMethod addProp [name :Dynamic position :Continuation cc]
    (let [name (FuzzyMapTools.bestMatch props name)
            prop (dictGet props name)
            position (resolvePosition position)]
        (dictSet .props (_currentScene) name (objectWith position prop))
        (director.showProp prop position (appearanceFlag shownProps name) .camera (_currentScene) cc)))

(hollywooMethod removeProp [name :Continuation cc]
    (.remove .props (_currentScene) name)
    (director.hideProp (dictGet props name) .camera (_currentScene) cc))

// Dialogue:

(hollywooMethod intercut [:Map<String,String> actorNamesToSceneNames :Continuation cc]
    (set intercutMap (new FuzzyMap<String>))
    (doFor =>actor scene actorNamesToSceneNames
        (dictSet intercutMap actor scene))
    (cc))

(hollywooMethod endIntercut [:Continuation cc]
    (set intercutMap null)
    (cc))

(hollywooMethod timedTitleCard [:Bool skipping time :Array<String> lines :Continuation cc]
    (when skipping
        (cc)
        (return))
    (let [cc ->{(director.hideTitleCard)(cc)}]
        (director.showTitleCard lines
            (makeCC
                // Allow skipping
                (director.startWaitForInput cc)
                (delay skipping time cc)))))

// TODO themed titleCard (wait for song or sound)


(hollywooMethod superText [:Bool skipping text :Continuation cc]
    (dialogHistory.push (Super text))
    (if skipping
            (cc)
        // Skip voice track handling:
        // TODO don't skip it when playing silent dialog
        (director.showDialog "" Super "" text cc)))

(hollywooMethod timedSuperText [:Bool skipping text :Dynamic sec :Continuation cc]
    (when skipping
        (dialogHistory.push (Super text))
        (cc)
        (return))
    (let [cc ->:Void {(director.hideDialog) (cc)}]
        (superText skipping text cc)
        (delay skipping sec cc)))

// TODO themed superText

(hollywooMethod normalSpeech [:Bool skipping actorName wryly text :Continuation cc]
    (processIntercut actorName
        (makeCC
            (showDialog skipping actorName (OnScreen (dictGet .characters (_currentScene) actorName)) wryly text cc))))

(hollywooMethod offScreenSpeech [:Bool skipping actorName wryly text :Continuation cc]
    (showDialog skipping actorName (OffScreen (dictGet actors actorName)) wryly text cc))

(hollywooMethod voiceOver [:Bool skipping actorName wryly text :Continuation cc]
    (showDialog skipping actorName (VoiceOver (dictGet actors actorName)) wryly text cc))

(hollywooMethod onPhoneSpeech [:Bool skipping actorName wryly text :Continuation cc]
    (processIntercut actorName
        (makeCC
            (showDialog skipping actorName (ifLet [charOnScreen (try (dictGet .characters (_currentScene) actorName) (catch [e] null))]
                                            (OnScreen charOnScreen)
                                        (FromPhone (dictGet actors actorName))) wryly text cc))))

(hollywooMethod customSpeech [:Bool skipping type actorName wryly args text :Continuation cc]
    (processIntercut actorName
        (makeCC
            (showDialog skipping actorName (Custom type (dictGet .characters (_currentScene) actorName) args) wryly text cc))))

(hollywooMethod timedCutToBlack [:Bool skipping seconds :Continuation cc]
    (when skipping
        (cc)
        (return))
    (director.showBlackScreen)
    (delay skipping seconds ->:Void {(director.hideBlackScreen)(cc)}))

(hollywooMethod cutToBlack [:Bool skipping :Continuation cc]
    (unless skipping
        (director.showBlackScreen))
    (cc))

(hollywooMethod endCutToBlack [:Bool skipping :Continuation cc]
    (unless skipping
        (director.hideBlackScreen))
    (cc))

(hollywooMethod rollCredits [:Bool skipping :String creditsTSV :Continuation cc &opt :Float timeLimit]
    (when skipping
        (cc)
        (return))
    (director.rollCredits
        (let [creditsData
                    (for line (.split .content (Stream.fromString creditsTSV) "\n") (line.split "\t"))
                headings
                    []    
                edgeCaseCredits
                    (new Map<String,String>)
                headingIndices
                    (new Map<String,Int>)
                headingData
                    (new Map<String,Array<Array<String>>>)]
            // Find headings
            (doFor [idx data] (enumerate creditsData)
                (case data
                    ((or [heading] [heading ""])
                        (headings.push heading)
                        (dictSet headingIndices heading idx)
                        (dictSet headingData heading []))
                    ((when (StringTools.endsWith heading ":") ["" heading])
                        (headings.push (substr heading 0 -1))
                        (dictSet headingIndices (substr heading 0 -1) idx)
                        (dictSet headingData (substr heading 0 -1) []))
                    (otherwise)))
            
            // Sort loadedCredits by headings and check for missing headings
            (doFor data loadedCredits
                (case data
                    ([heading credit _sourceOrUrl]
                        (ifLet [idx (dictGet headingIndices heading)]
                                (let [edgeCaseCredit (dictGet edgeCaseCredits heading)
                                        hd (dictGet headingData heading)
                                        // Push unless given a duplicate:
                                        hdPush ->:Void data
                                                    (let [dataStr (data.toString)]
                                                        (when (= credit edgeCaseCredit)
                                                            (return))
                                                        (doFor d hd
                                                            (when (= (d.toString) dataStr)
                                                                (return)))
                                                        (hd.push data))
                                        headingLineData (nth creditsData idx)]
                                    (case headingLineData
                                        ([heading ""]
                                            (dictSet edgeCaseCredits heading credit)
                                            (setNth headingLineData 1 credit))
                                        (["" heading]
                                            (hdPush ["" "   ${credit}"]))
                                        ((or [heading] [heading _])
                                            (hdPush ["" credit]))
                                        (never otherwise)))
                                
                            (throw "no heading $heading to place credit $data")))
                    (otherwise
                        (throw "unsupported credit data $data"))))

            // Insert sorted credits under headings
            (doFor heading (reverse headings)
                (let [idx (dictGet headingIndices heading)
                        hd (dictGet headingData heading)]
                    (doFor data (reverse hd)
                        (creditsData.insert (+ idx 1) data))))

            // Return the formatting enum list
            (for data creditsData
                (case data
                    ([]
                        Break)
                    ([col1]
                        (OneColumn col1))
                    ([col1 col2]
                        (TwoColumn col1 col2))
                    ([col1 col2 col3]
                        (ThreeColumn col1 col2 col3))
                    (otherwise
                        (throw "unsupported credits line $data")))))
        
        cc
        timeLimit))

(hollywooMethod themedRollCredits [:Bool skipping :String creditsTSV :String songKey :Continuation cc &opt :Float volumeMod]
    (when skipping
        (cc)
        (return))
    (playSong skipping songKey (makeCC null) volumeMod)
    (rollCredits
        skipping 
        creditsTSV
        (makeCC
            (stopSong skipping cc))
        (director.getSongLength (dictGet songs songKey))))